var documenterSearchIndex = {"docs":
[{"location":"project/#Project-Setup-1","page":"Project Setup","title":"Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Part of the functionality of DrWatson is creating and navigating through a project setup consistently. This works even if you move your project to a different location/computer or send it to a colleague with a different Julia installation. In addition, the navigation process is identical across any project that uses DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This can \"just work\" (TM) because of the following principles:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Your science project is also a Julia project defined by a Project.toml file. This way the project tracks the used packages (and their versions) and can be shared with any other Julia user.\nYou first activate this project environment before running any code. This way you ensure that your project runs on the specified package installation (instead of the global one). See Activating a Project for ways to do this.\nYou use the functions projectdir, datadir, etc. from DrWatson to navigate your project (see Navigating a Project).","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Importantly, our suggested project setup was designed to be fully reproducible, see Reproducibility.","category":"page"},{"location":"project/#Default-Project-Setup-1","page":"Project Setup","title":"Default Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"DrWatson suggests a universal project structure for any scientific project, which is the following:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"using DrWatson\nstruct ShowFile\n    file::String\nend\nfunction Base.show(io::IO, ::MIME\"text/plain\", f::ShowFile)\n    write(io, read(f.file))\nend","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"ShowFile(dirname(pathof(DrWatson))*\"/defaults/project_structure.txt\") # hide","category":"page"},{"location":"project/#src-vs-scripts-1","page":"Project Setup","title":"src vs scripts","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Seems like src and scripts folders have pretty similar functionality. However there is a distinction between these two. You can follow these mental rules to know where to put file.jl:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If upon include(\"file.jl\") there is anything being produced, be it data files, plots or even output to the console, then it should be in scripts.\nIf it is functionality used across multiple files or pipelines, it should be in src.\nsrc should only contain files that define functions or types but not output anything.","category":"page"},{"location":"project/#Initializing-a-Project-1","page":"Project Setup","title":"Initializing a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To initialize a project as described in the Default Project Setup section, we provide the following function:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"initialize_project","category":"page"},{"location":"project/#DrWatson.initialize_project","page":"Project Setup","title":"DrWatson.initialize_project","text":"initialize_project(path [, name]; kwargs...)\n\nInitialize a scientific project expected by DrWatson in path (directory representing an empty folder). If name is not given, it is assumed to be the folder's name.\n\nThe new project remains activated for you to immidiately add packages.\n\nKeywords\n\nreadme = true : adds a README.md file.\nauthors = nothing : if a string or container of strings, adds the authors in the Project.toml file and README.md.\nforce = false : If the path is not empty then throw an error. If however force is true then recursively delete everything in the path and create the project.\ngit = true : Make the project a Git repository.\nplaceholder = false : Add hidden place holder files in each default folder to ensure that project is maintained when the directory is cloned. Should be used only when git = true. Will throw a warning if used with git = false\n\n\n\n\n\n","category":"function"},{"location":"project/#Activating-a-Project-1","page":"Project Setup","title":"Activating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This part of DrWatson's functionality requires you to have your scientific project (and as a consequence, the Julia project) activated. This can be done in multiple ways:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"doing Pkg.activate(\"path/to/project\") programmatically\nusing the startup flag --project path when starting Julia\nby setting the JULIA_PROJECT environment variable\nusing the functions quickactivate and findproject offered by DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"We recommend the fourth approach, although it does come with a caveat (see the docstring of quickactivate).","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"quickactivate\n@quickactivate\nfindproject","category":"page"},{"location":"project/#DrWatson.quickactivate","page":"Project Setup","title":"DrWatson.quickactivate","text":"quickactivate(path [, name::String])\n\nActivate the project found by recursively searching the path and its parents for a valid Julia project file. Optionally check if name is the same as the activated project's name. If it is not, throw an error. See also @quickactivate. Do nothing if the project found is already active, or if no project file is found.\n\nExample:\n\nusing DrWatson\nquickactivate(\"path/to/project\", \"Best project in the WOLRLDD\")\n\nNotice that this function is first activating the project and then checking if it matches the name.\n\nwarning: Warning\nNote that to access quickactivate you need to be using DrWatson. For this to be possible DrWatson must be already added in the existing global environment. The version of DrWatson loaded therefore will be the one of the global environment, and not of the activated project. To avoid unexpected behavior take care so that these two versions coincide.In addition please be very careful to write:using DrWatson # YES\nquickactivate(@__DIR__)\nusing Package1, Package2\n# do stuffinstead of the erroneous:using DrWatson, Package1, Package2 # NO!\nquickactivate(@__DIR__)\n# do stuffThis ensures that the packages you use will all have the versions dictated by your activated project (besides DrWatson, since this is impossible to do using quickactivate).\n\n\n\n\n\n","category":"function"},{"location":"project/#DrWatson.@quickactivate","page":"Project Setup","title":"DrWatson.@quickactivate","text":"@quickactivate\n\nEquivalent with quickactivate(@__DIR__).\n\n@quickactivate name::String\n\nEquivalent with quickactivate(@__DIR__, name).\n\n\n\n\n\n@quickactivate ProjectName::Symbol\n\nIf given a Symbol then first quickactivate(@__DIR__, string(ProjectName)), and then do using ProjectName, as if the symbol was representing a module name.\n\nThis ties with Making your project a usable module functionality, see the docs for an example.\n\n\n\n\n\n","category":"macro"},{"location":"project/#DrWatson.findproject","page":"Project Setup","title":"DrWatson.findproject","text":"findproject(path = pwd()) -> project_path\n\nRecursively search path and its parents for a valid Julia project file (anything in Base.project_names). If it is found return its path, otherwise issue a warning and return nothing.\n\nThe function stops searching if it hits either the home directory or the root directory.\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that to get the current project's name you can use:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectname","category":"page"},{"location":"project/#DrWatson.projectname","page":"Project Setup","title":"DrWatson.projectname","text":"projectname()\n\nReturn the name of the currently active project.\n\n\n\n\n\n","category":"function"},{"location":"project/#Including-Julia-packages/modules-in-src-1","page":"Project Setup","title":"Including Julia packages/modules in src","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that the project initialized by DrWatson does not represent a Julia package. It represents a scientific project. That being said, it is often the case that you want to develop normal Julia Modules (and perhaps later publish them as packages) inside your project, so that you can later use them in your code with using ModuleName. The proper way to do this is to initialize Julia packages, using the package manager, inside the src folder, using these steps:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Active your project that uses DrWatson.\nChange directory to the project's main folder (important!).\nGo into package mode and initialize a package with the name that you want: generate src/ModuleName\ndev the local path to ModuleName using the package manager: dev src/ModuleName. Notice that this command uses a local path, see this PR for more details.\nIf you don't care to make this module a Julia package, simply delete its .git folder: src/Modulename/.git.\nIf you do care about publishing this module as a Julia package, then it is mandatory to keep it as git-repository. In this case it is sensible to put src/ModuleName/.git into the main .gitignore file.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Now whenever you do using ModuleName, the local version will be used. This will still work even if you transfer your project to another computer, because the Manifest.toml file stores the local path.","category":"page"},{"location":"project/#Navigating-a-Project-1","page":"Project Setup","title":"Navigating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To be able to navigate the project consistently, DrWatson provides the core function","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectdir","category":"page"},{"location":"project/#DrWatson.projectdir","page":"Project Setup","title":"DrWatson.projectdir","text":"projectdir()\n\nReturn the directory of the currently active project.\n\nprojectdir(args...) = joinpath(projectdir(), args...)\n\nJoin the path of the currently active project with args (typically other subfolders).\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Besides the above, the following derivative functions","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"datadir()\nsrcdir()\nplotsdir()\nscriptsdir()\npapersdir()","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"behave exactly like projectdir but have as root the appropriate subdirectory. These are also defined due to the frequent use of these subdirectories.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"All of these functions take advantage of joinpath, ensuring an error-free path creation that works across different operating systems. It is heavily advised to use projectdir and derivatives by giving them the subpaths as arguments, instead of using multiplication between paths:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"datadir(\"foo\", \"test.jld2\") # preferred\ndatadir() * \"/foo/test.jld2\" # not recommended","category":"page"},{"location":"project/#Custom-directory-functions-1","page":"Project Setup","title":"Custom directory functions","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"It is straightforward to make custom directory functions if there is a directory you created that you access more often. Simply define","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"customdir(args...) = projectdir(\"custom\", args...)","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"to make the customdir version that works exactly like e.g. datadir but for \"custom\" instead of \"data\".","category":"page"},{"location":"project/#Reproducibility-1","page":"Project Setup","title":"Reproducibility","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"The project setup approach that DrWatson suggests is designed to work flawlessly with Julia standards, to be easy to share and to be fully reproducible. There are three reasons that true reproducibility is possible:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"The project's used packages are embedded in the project because of Manifest.toml.\nThe navigation around the folders of the project uses local directories.\nThe project is a Git repository, which means that it has a detailed (and re-traceable) history of all changes and additions.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If you send your entire project folder to a colleague, they only need to do:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"julia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"to use your project (assuming of course that you are both using the same Julia installation and version). All required packages and dependencies will be installed and then any script that was running in your computer will also be running in their computer in the same way!","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"In addition, with DrWatson you have the possibility of \"tagging\" each simulation created with the commit id, see the discussion around gitdescribe and tag!. This way, any data result obtained at any moment can be truly reproduced simply by resetting the Git tree to the appropriate commit and running the code.","category":"page"},{"location":"project/#Transitioning-an-existing-project-to-DrWatson-1","page":"Project Setup","title":"Transitioning an existing project to DrWatson","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If you already have an existing project with scripts and data etc., then there is no reason to use the initialize_project function. The only requirement is that everything that belongs to your project is contained within a single folder (which can have an arbitrary amount of subfolders). If your project is already a Julia project (which means it has its own Project.toml and Manifest.toml files), then there is nothing more necessary to be done, you can immediatelly start using DrWatson with it. Although we recommend following the Default Project Setup, you don't have to do this either, since you can create your own Custom directory functions.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If your project is not also a Julia project, the steps necessary are still quite simple. You can do:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"julia> cd(\"path/to/project\")\npkg> activate .\npkg> add Package1 Package2 ...","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Julia will automatically make the Project.toml and Manifest.toml files for you as you add packages used by your project.","category":"page"},{"location":"real_world/#Real-World-Examples-1","page":"Real World Examples","title":"Real World Examples","text":"","category":"section"},{"location":"real_world/#Easy-local-directories-1","page":"Real World Examples","title":"Easy local directories","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"I setup all my science projects using DrWatson's suggested setup, using initialize_project. Then, every file in every project has a start that looks like this:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"MagneticBilliardsLyapunovs\")\nusing DynamicalBilliards, PyPlot, LinearAlgebra\n\ninclude(srcdir(\"plot_perturbationgrowth.jl\"))\ninclude(srcdir(\"unitcells.jl\"))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In all projects I save data/plots using datadir/plotdir:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"@tagsave(datadir(\"mushrooms\", \"Λ_N=$N.jld2\"), (@dict Λ Λσ ws hs description))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The advantage of this approach is that it will always work regardless of if I move the specific file to a different subfolder (which is very often necessary) or whether I move the entire project folder somewhere else! Please be sure you have understood the caveat of using quickactivate!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example from another project. You will notice that another advantage is that I can use identical syntax to access the data or source folders even though I have different projects!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate \"EmbeddingResearch\"\nusing Parameters\nusing TimeseriesPrediction, LinearAlgebra, Statistics\n\ninclude(srcdir(\"systems\", \"barkley.jl\"))\ninclude(srcdir(\"nrmse.jl\"))\n\n# stuff...\n\nsave(datadir(\"sim\", \"barkley\", \"astonishing_results.jld2\"), data)","category":"page"},{"location":"real_world/#Making-your-project-a-usable-module-1","page":"Real World Examples","title":"Making your project a usable module","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For some projects, it is often the case that some packages and files from the source folder are loaded at the beginning of every file of the project. For example, I have a project that I know that for any script I will write, the first five lines will be:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\n@quickactivate \"AlbedoProperties\"\nusing Dates, Statistics, NCDatasets\ninclude(srcdir(\"core.jl\"))\ninclude(srcdir(\"style.jl\"))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It would be quite convenient to group all of these commands into one file and instead load that file, for example do include(srcdir(\"everything.jl\")) and all commands are in there.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We can do even better though! Because of the way Julia handles project and module paths, it is in fact possible to transform the currently active project into a usable module. If one defines inside the src folder a file AlbedoProperties.jl and in that file define a module AlbedoProperties (notice that these names must match exactly the project name), then upon doing using AlbedoProperties Julia will in fact just bring this module into scope.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"So what I end up doing (for some projects where this makes sense) is creating the aforementioned file and putting inside things like","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"module AlbedoProperties\n\nusing Reexport\n@reexport using Dates, Statistics\nusing NCDatasets: NCDataset, dimnames, NCDatasets\nexport NCDataset, dimnames\ninclude(\"core.jl\") # this file now also has export statements\ninclude(\"style.jl\")\n\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and then the header of all my files is transformed to","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\n@quickactivate :AlbedoProperties","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"which takes advantage of @quickactivate's feature to essentially combine the commands @quickactivate \"AlbedoProperties\" and using AlbedoProperties into one.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"If you intend to share your project with a non-DrWatson user, you should consider the verbose syntax instead, as the above syntax is not really clear for someone that doesn't know what @quickactivate does.","category":"page"},{"location":"real_world/#savename-and-tagging-1","page":"Real World Examples","title":"savename and tagging","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The combination of using savename and tagsave makes it easy and fast to save output in a way that is consistent, robust and reproducible. Here is an example from a project:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"EmbeddingResearch\")\nusing TimeseriesPrediction, LinearAlgebra, Statistics\ninclude(srcdir(\"systems\", \"barkley.jl\"))\n\nΔTs = [1.0, 0.5, 0.1] # resolution of the saved data\nNs = [50, 150] # spatial extent\nfor N ∈ Ns, ΔT ∈ ΔTs\n    T = 10050 # we can offset up to 1000 units\n    every = round(Int, ΔT/barkley_Δt)\n    seed = 1111\n\n    simulation = @ntuple T N ΔT seed\n    U, V = barkley(T, N, every; seed = seed)\n\n    @tagsave(\n        datadir(\"sim\", \"bk\", savename(simulation, \"jld2\")),\n        @dict U V simulation\n    )\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This saves files that look like:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"path/to/project/data/sim/bk_N=50_T=10050_seed=1111_ΔT=1.jld2","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and each file is a dictionary that has my data fields: :U, :V, :simulation, but also :gitcommit, :script. When I read this file I know exactly what was the source code that produced it (provided that I am not sloppy and commit code changes regularly :P).","category":"page"},{"location":"real_world/#Customizing-savename-1","page":"Real World Examples","title":"Customizing savename","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a simple example for customizing savename. We are using a common struct Experiment across different experiments with cats and mice. In this example we are also using Parameters.jl for a convenient default constructor.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We first define the relevant types.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson, Dates\nusing Base: @kwdef\n\n# Define a type hierarchy we use at experiments\nabstract type Species end\nstruct Mouse <: Species end\nstruct Cat <: Species end\n\n# @with_kw comes from Parameters.jl\n@kwdef struct Experiment{S<:Species}\n    n::Int = 50\n    c::Float64 = 10.0\n    x::Float64 = 0.2\n    date::Date = Date(Dates.now())\n    species::S = Mouse()\n    scientist::String = \"George\"\nend\n\ne1 = Experiment()\ne2 = Experiment(species = Cat())","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For analyzing our experiments we need information about the species used, and to use multiple dispatch latter on we decided to make this information associated with a Type. This is why we defined Species.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, we want to customize savename. We start by extending DrWatson.default_prefix:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_prefix(e::Experiment) = \"Experiment_\"*string(e.date)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"However this is not good enough for us, as the information about the species is not contained in savename and also the date information is duplicated. We have to extend DrWatson.default_allowed to specify which data types should be extended in savename:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_allowed(::Experiment) = (Real, String, Species)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"To make printing of Species better we can extend Base.string, which is what DrWatson uses internally in savename to display values.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Base.string(::Mouse) = \"mouse\"\nBase.string(::Cat) = \"cat\"\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Lastly, let's say that the information of which scientist performed the experiment is not really relevant for savename. We can extend the last method, DrWatson.allaccess:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.allaccess(::Experiment) = (:n, :c, :x, :species)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"so that only those four fields will be used (notice that the date field is already used in default_prefix). We finally have:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"println( savename(e1) )\nprintln( savename(e2) )","category":"page"},{"location":"real_world/#savename-and-nested-containers-1","page":"Real World Examples","title":"savename and nested containers","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In the case of user-defined structs and projects of significant complexity, it is often necessary that your \"main\" container has other containers as subfields. savename can adapt to these situations as well. Consider the following example, where I need a core struct that represents a spatio temporal system, and its simulation:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"struct SpatioTemporalSystem\n    model::String # system codeword\n    N        # Integer or Tuple of integers: spatial extent\n    Δt::Real # sampling time in real time units\n    p        # parameters. nothing or Dict{Symbol}\nend\nconst STS = SpatioTemporalSystem\n\nstruct SpatioTemporalTimeseries\n    sts::STS\n    T::Int       # total frame amount\n    ic           # initial condition (matrix, string, seed)\n    fields::Dict # resulting timeseries, dictionary of string to vector\nend\nconst STT = SpatioTemporalTimeseries","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For my use case, p can be nothing or it can be a dictionary itself, containing the possible parameters the spatiotemporal systems can have. To adapt savename to situations like this, we use the functionality surrounding DrWatson.default_expand.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Expanding the necessary methods allows me to do:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.allaccess(c::STS) = (:N, :Δt, :p)\nDrWatson.default_prefix(c::STS) = c.model\nDrWatson.default_allowed(c::STS) = (Real, Tuple, Dict, String)\nDrWatson.default_expand(c::STS) = [\"p\"]\n\nbk = STS(\"barkley\", 60, 0.1, nothing)\nsavename(bk)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and when I do want to use different parameters than the default:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"a = 0.3; b = 0.5\nbk = STS(\"barkley\", 60, 0.1, @dict a b)\nsavename(bk)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Expanding to the second struct is also fine:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_prefix(c::STT) = savename(c.sts)\nstt = STT(bk, 1000, nothing, Dict(\"U\"=>rand(100), \"V\"=>rand(100)))\nsavename(stt)","category":"page"},{"location":"real_world/#Stopping-\"Did-I-run-this?\"-1","page":"Real World Examples","title":"Stopping \"Did I run this?\"","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It can become very tedious to have a piece of code that you may or may not have run and may or may not have saved the produced data. You then constantly ask yourself \"Did I run this?\". Typically one uses isfile and an if clause to either load a file or run some code. Especially in the cases where the code takes only a couple of minutes to finish you are left in a dilemma \"Is it even worth it to save?\".","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This is the dilemma that produce_or_load resolves. You can wrap your code in a function and then produce_or_load will take care of the rest for you! I found it especially useful in scripts that generate figures for a publication.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example; originally I had this piece of code:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"HTEST = 0.1:0.1:2.0\nWS = [0.5, 1.0, 1.5]\nN = 10000; T = 10000.0\n\ntoypar_h = [[] for l in WS]\nfor (wi, w) in enumerate(WS)\n    println(\"w = $w\")\n    for h in HTEST\n        toyp = toyparameters(h, w, N, T)\n        push!(toypar_h[wi], toyp)\n    end\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"that was taking some minutes to run. To use the function produce_or_load I first have to wrap this code in a high level function like so:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"function g(d)\n    HTEST = 0.1:0.1:2.0\n    WS = [0.5, 1.0, 1.5]\n    @unpack N, T = d\n    toypar_h = [[] for l in WS]\n\n    for (wi, w) in enumerate(WS)\n        println(\"w = $w\")\n        for h in HTEST\n            toyp = toyparameters(h, w, N, T)\n            push!(toypar_h[wi], toyp)\n        end\n    end\n    return @strdict toypar_h\nend\n\nN = 2000; T = 2000.0\ndata, file = produce_or_load(\n    datadir(\"mushrooms\", \"toy\"), # path\n    @dict(N, T), # container\n    g, # function\n    prefix = \"fig5_toyparams\" # prefix for savename\n)\n@unpack toypar_h = data","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, every time I run this code block the function tests automatically whether the file exists. Only if it does not, then the code is run while the new result is saved to ensure I won't have to run it again.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The extra step is that I have to extract the useful data I need from the container file. Thankfully the @unpack macro from Parameters.jl makes this super easy.","category":"page"},{"location":"real_world/#Preparing-and-running-jobs-1","page":"Real World Examples","title":"Preparing & running jobs","text":"","category":"section"},{"location":"real_world/#Preparing-the-dictionaries-1","page":"Real World Examples","title":"Preparing the dictionaries","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a shortened script from a project that uses dict_list:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\n\ngeneral_args = Dict(\n    \"model\" => [\"barkley\", \"kuramoto\"],\n    \"noise\" => 0.075,\n    \"noisy_training\" => [true, false],\n    \"N\" => [100],\n    \"embedding\" => [ #(γ, τ, r, c)\n    (4, 5, 1, 0.34), (4, 6, 1, 0.28)]\n)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nprintln(\"Total dictionaries made: \", length(dicts))\ndicts[1]","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, how you use these dictionaries is up to you. Typically each dictionary is given to a main-like Julia function which extracts the necessary data and calls the necessary functions.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Let's say I have written a function that takes in one of these dictionaries and saves the file somewhere locally:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"function cross_estimation(data)\n    γ, τ, r, c = data[\"embedding\"]\n    N = data[\"N\"]\n    # add fake results:\n    data[\"x\"] = rand()\n    data[\"error\"] = rand(10)\n    # Save data:\n    prefix = datadir(\"results\", data[\"model\"])\n    get(data, \"noisy_training\", false) && (prefix *= \"_noisy\")\n    get(data, \"symmetric_training\", false) && (prefix *= \"_symmetric\")\n    sname = savename((@dict γ τ r c N), \"jld2\")\n    mkpath(datadir(\"results\", data[\"model\"]))\n    save(datadir(\"results\", data[\"model\"], sname), data)\n    return true\nend","category":"page"},{"location":"real_world/#Using-map-and-pmap-1","page":"Real World Examples","title":"Using map and pmap","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"One way to run many simulations is with map (identical process for using pmap). To run all my simulations I just do:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nmap(cross_estimation, dicts) # or pmap\n\n# load one of the files to be sure everything is ok:\nfilename = readdir(datadir(\"results\", \"barkley\"))[1]\nfile = load(datadir(\"results\", \"barkley\", filename))","category":"page"},{"location":"real_world/#Using-a-Serial-Cluster-1","page":"Real World Examples","title":"Using a Serial Cluster","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In case that I can't store the results of dict_list in memory, I have to change my approach and load them from disk. This is easy with the function tmpsave.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Instead of using Julia to run all jobs from one process with map/pmap one can use Julia to submit many jobs to a cluster que. For our example above, the Julia program that does this would look like this:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nres = tmpsave(dicts)\nfor r in res\n    submit = `qsub -q queuename julia runjob.jl $r`\n    run(submit)\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now the file runjob.jl would have contents that look like:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"f = ARGS[1]\ndict = load(projectdir(\"_research\", \"tmp\", f), \"params\")\ncross_estimation(dict)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"i.e. it just loads the dict and straightforwardly uses the \"main\" function cross_estimation. Remember to routinely clear the tmp directory! You could do that by e.g. adding a line rm(projectdir(\"_research\", \"tmp\", f) at the end of the runjob.jl script.","category":"page"},{"location":"real_world/#Listing-completed-runs-1","page":"Real World Examples","title":"Listing completed runs","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Continuing from the Preparing & running jobs section, we now want to collect the results of all these simulations into a single DataFrame. We will do that with the function collect_results!.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It is quite simple actually! But because we don't want to include the error, we have to black-list it:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DataFrames # this is necessary to access collect_results!\nbl = [\"error\"]\nres = collect_results!(datadir(\"results\"); black_list = bl, subfolders = true)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We can take also advantage of the basic processing functionality of collect_results! to use the excluded \"error\" column, replacing it with its average value:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using Statistics: mean\nspecial_list = [:avrg_error => data -> mean(data[\"error\"])]\nres = collect_results(\n      datadir(\"results\"),\n      black_list = bl,\n      special_list = special_list,\n      subfolders = true\n)\n\nselect!(res, Not(:path)) # don't show path this time","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As you see here we used collect_results instead of the in-place version, since there already exists a DataFrame with all results processed (and thus everything would be skipped).","category":"page"},{"location":"real_world/#Adapting-to-new-data/parameters-1","page":"Real World Examples","title":"Adapting to new data/parameters","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We once again continue from the above example. But we now need to run some new simulations with some new parameters that do not exist in the old simulations... Well, DrWatson says \"no problem!\" :)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Let's save these new parameters in a different subfolder, to have a neatly organized project:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"general_args_new = Dict(\n    \"model\" => [\"bocf\"],\n    \"symmetry\" => \"radial\",\n    \"symmetric_training\" => [true, false],\n    \"N\" => [100],\n    \"embedding\" => [ #(γ, τ, r, c)\n    (4, 5, 1, 0.34), (4, 6, 1, 0.28)]\n)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As you can see, there here there are two parameters not existing in previous simulations, namely \"symmetry\", \"symmetric_training\". In addition, the parameters \"noise\", \"noisy_training\" that existed in the previous simulations do not exist in the current one.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"No problem though, let's run the new simulations:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args_new)\nmap(cross_estimation, dicts)\n\n# load one of the files to be sure everything is ok:\nfilename = readdir(datadir(\"results\", \"bocf\"))[1]\nfile = load(datadir(\"results\", \"bocf\", filename))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Alright, now we want to add these new runs to our existing dataframe that has collected all previous results. This is straight-forward:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"res = collect_results!(datadir(\"results\"); black_list = bl, subfolders = true)\n\nselect!(res, Not(:path)) # don't show path this time","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"All missing entries were adjusted automatically :)","category":"page"},{"location":"real_world/#Defining-parameter-sets-with-restrictions-1","page":"Real World Examples","title":"Defining parameter sets with restrictions","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As already demonstrated in the examples above, for functions where the set of input parameters is the same for each simulation run, a basic dictionary can be used to define these parameters. However, often some of the parameters or values should only be considered if another parameter is also included in the set or has a specific value. The macro @onlyif allows to place such restrictions on values and parameters. The following dictionary defines values and parameters for a genetic algorithm:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"ga_parameters = Dict(\n    :population_size => [20,50,100],\n    :selection => [\"roulette-selection\", \"SUS\", \"tournament-selection\", \"linear ranking\"],\n    :fitness_scaling => @onlyif(:selection in (\"SUS\", \"roulette-selection\"), collect(1.0:20.0)),\n    :tournamet_size => @onlyif(:selection == \"tournament-selection\", collect(2:10)),\n    :chromosome => [:A, @onlyif(begin\n        size_constr = (:population_size <= 50)\n        select_constr = (:selection != \"SUS\")\n        size_constr && select_constr\n    end, :B)])","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(ga_parameters)\nlength(dicts)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts[1]","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The parameter restriction for the chromosome type shows that one can use arbitrary Julia expressions that return true or false. In this case, first the conditions for the population size and for the selection method are evaluated and stored. The expression then only returns true, if both conditions are met, thus restricting the usage of chromosome type :B.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As @onlyif is meant to be used with dict_list, it supports the vector notation used for defining possible parameter values. This is achieved by automatically broadcasting every @onlyif call over Vector arguments, which allows chaining those calls to combine conditions. So in terms of the result, @onlyif( :a == 2, [5, @onlyif(:b == 4, 6)]) is equivalent to [@onlyif( :a == 2, 5), @onlyif(:a == 2 && :b == 4, 6)].","category":"page"},{"location":"real_world/#Advanced-Usage-of-collect_results-1","page":"Real World Examples","title":"Advanced Usage of collect_results","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"At some point in your work you may want to run a single function that returns multiple fields that you want to include in your results DataFrame. Depending on the problem you are trying to solve it may just make more sense to use a single function that extracts most or all of the meta-data. For this case DrWatson has another syntax available. Let us, for the sake of simplicity, assume that your data files contain a very long array of numbers called \"manynumbers\" and the information that you care about are the three largest values.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"One way to implement this would be to write","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"special_list = [\n    :first  => data -> sort(data[\"manynumbers\"])[1],\n    :second => data -> sort(data[\"manynumbers\"])[2],\n    :third  => data -> sort(data[\"manynumbers\"])[3],\n    ]","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"which makes very obvious that there should be a better way to do this. There is no point in sorting the very long vector three times. A better thing to do is the following","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"function largestthree(data)\n    sorted = sort(data[\"manynumbers\"])\n    return [:first  => sorted[1],\n            :second => sorted[2],\n            :third  => sorted[3]]\nend\n\nspecial_list = [largestthree,]","category":"page"},{"location":"name/#Naming-Simulations-1","page":"Naming Simulations","title":"Naming Simulations","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Here we overview functionality that helps you quickly produce containers of parameters and name them using a consistent and intuitive naming scheme.","category":"page"},{"location":"name/#Naming-Schemes-1","page":"Naming Simulations","title":"Naming Schemes","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"A robust naming scheme allows you to create quick names for simulations, create lists of simulations, check existing simulations, etc. More importantly it allows you to easily create simulation-based names consistently and deterministically.","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"This is what the function savename does. Of course, you don't have to use it only for using names to save files. You could use it for anything that fits you (like e.g. adding identifiers to tabular data). savename is also surprisingly useful for creating titles of figures, e.g. savename(c; connector = \", \").","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"savename","category":"page"},{"location":"name/#DrWatson.savename","page":"Naming Simulations","title":"DrWatson.savename","text":"savename([prefix,], c [, suffix]; kwargs...)\n\nCreate a shorthand name, commonly used for saving a file or as a figure title, based on the parameters in the container c (Dict, NamedTuple or any other Julia composite type). If provided use the prefix and end the name with .suffix (i.e. you don't have to include the . in your suffix).\n\nThe function chains keys and values into a string of the form:\n\nkey1=val1_key2=val2_key3=val3\n\nwhile the keys are sorted alphabetically by default. If you provide the prefix/suffix the function will do:\n\nprefix_key1=val1_key2=val2_key3=val3.suffix\n\nassuming you chose the default connector, see below. Notice that prefix should not contain path separators to avoid compatibility issues  on different operating systems. For constructing paths, use the *dir()  methods or joinpath with savename() as the last parameter. See default_prefix for more.\n\nsavename can be conveniently combined with @dict or @ntuple. See also parse_savename and @savename.\n\nStandard keywords\n\nsort = true : Indicate whether the pairs are sorted alphabetically by keys. If not, they are sorted by the order of accesses. WARNING: the default accesses is not deterministic for Dict inputs.\ndigits = nothing, sigdigits = 3 : Floating point values are rounded using the round function with these keywords.\nconnector = \"_\" : string used to connect the various entries.\n\nCustomization keywords\n\nallowedtypes = default_allowed(c) : Only values of type subtyping anything in allowedtypes are used in the name. By default this is (Real, String, Symbol, TimeType).\naccesses = allaccess(c) : specify which specific keys you want to use with the keyword accesses. By default this is all possible keys c can be accessed with, see allaccess.\nignores = allignore(c) : You can also specify keys that you want to ignore with the keyword ignores. By default this is an empty tuple, see allignore. (keys in ignore are ignored even if they are in accesses)\nval_to_string = nothing : If not nothing, this is a function that converts any given value to a string representation, and allows for custom formatting. If given, digits, sigidigits are ignored.\nexpand::Vector{String} = default_expand(c) : keys that will be expanded to the savename of their contents, to allow for nested containers. By default is empty. Notice that the type of the container must also be allowed in allowedtypes for expand to take effect! The savename of the nested arguments is always called with its default arguments (so customization here is possible only by rolling your own container type). Containers leading to empty savename are skipped.\n\nExamples\n\nd = (a = 0.153456453, b = 5, mode = \"double\")\nsavename(d; digits = 4) == \"a=0.1535_b=5_mode=double\"\nsavename(\"n\", d) == \"n_a=0.153_b=5_mode=double\"\nsavename(d, \"n\") == \"a=0.153_b=5_mode=double.n\"\nsavename(\"n\", d, \"n\"; connector = \"-\") == \"n-a=0.153-b=5-mode=double.n\"\nsavename(d, allowedtypes = (String,)) == \"mode=double\"\n\nrick = (never = \"gonna\", give = \"you\", up = \"!\");\nsavename(rick) == \"give=you_never=gonna_up=!\" # keys are sorted!\nsavename(rick; ignores = [\"up\"]) == \"give=you_never=gonna\"\n\n\n\n\n\n","category":"function"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Notice that this naming scheme integrates perfectly with Parameters.jl.","category":"page"},{"location":"name/#Convenience-functions-1","page":"Naming Simulations","title":"Convenience functions","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Convenience functions are provided to shorten common function calls and easily create named tuples, dictionaries as well as switch between them:","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"@dict\n@strdict\n@ntuple\n@savename\nntuple2dict\ndict2ntuple\ntostringdict\ntosymboldict","category":"page"},{"location":"name/#DrWatson.@dict","page":"Naming Simulations","title":"DrWatson.@dict","text":"@dict vars...\n\nCreate a dictionary out of the given variables that has as keys the variable names and as values their values.\n\nNotice: @dict a b is the correct way to call the macro. @dict a, b is incorrect. If you want to use commas you have to do @dict(a, b).\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = π/3;\n\njulia> @dict ω χ ζ\nDict{Symbol,Any} with 3 entries:\n  :ω => 5\n  :χ => \"test\"\n  :ζ => 1.0472\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@strdict","page":"Naming Simulations","title":"DrWatson.@strdict","text":"@strdict vars...\n\nSame as @dict but the key type is String.\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@ntuple","page":"Naming Simulations","title":"DrWatson.@ntuple","text":"@ntuple vars...\n\nCreate a NamedTuple out of the given variables that has as keys the variable names and as values their values.\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = 3.14;\n\njulia> @ntuple ω χ ζ\n(ω = 5, χ = \"test\", ζ = 3.14)\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@savename","page":"Naming Simulations","title":"DrWatson.@savename","text":"@savename vars...\n\nConvenient combination of chaining a call to @dict on vars and savename.\n\nExamples\n\njulia> a = 0.153456453; b = 5.0; mode = \"double\"\njulia> @savename a b mode\n\"a=0.153_b=5_mode=double\"\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.ntuple2dict","page":"Naming Simulations","title":"DrWatson.ntuple2dict","text":"ntuple2dict(nt) -> dict\n\nConvert a NamedTuple to a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.dict2ntuple","page":"Naming Simulations","title":"DrWatson.dict2ntuple","text":"dict2ntuple(dict) -> ntuple\n\nConvert a dictionary (with Symbol or String as key type) to a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.tostringdict","page":"Naming Simulations","title":"DrWatson.tostringdict","text":"tostringdict(d)\n\nChange a dictionary with key type Symbol to have key type String.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.tosymboldict","page":"Naming Simulations","title":"DrWatson.tosymboldict","text":"tosymboldict(d)\n\nChange a dictionary with key type String to have key type Symbol.\n\n\n\n\n\n","category":"function"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Notice that we also re-export the convenient @pack!, @unpack tools from UnPack.jl, because they play very well with @dict and similar functions. Be aware of the syntactic , difference: d = @dict a b c versus @unpack a, b, c = d.","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"@unpack\n@pack!","category":"page"},{"location":"name/#UnPack.@unpack","page":"Naming Simulations","title":"UnPack.@unpack","text":"@unpack a, b, c, ... = dict_or_typeinstance\n\nUnpack fields/properties/keys from a composite type, a Dict{Symbol}, a Dict{String}, or a module into variables.\n\nExample with dict:\n\nd = Dict{Symbol,Any}(:a=>5.0,:b=>2,:c=>\"Hi!\")\n@unpack a, c = d\na == 5.0 #true\nc == \"Hi!\" #true\n\nExample with type:\n\nstruct A; a; b; c; end\nd = A(4,7.0,\"Hi\")\n@unpack a, c = d\na == 4 #true\nc == \"Hi\" #true\n\nNote that its functionality can be extended by adding methods to the UnPack.unpack function.\n\n\n\n\n\n","category":"macro"},{"location":"name/#UnPack.@pack!","page":"Naming Simulations","title":"UnPack.@pack!","text":"@pack! dict_or_typeinstance = a, b, c, ...\n\nPack variables into a mutable composite type, a Dict{Symbol}, or a Dict{String}.\n\nExample with dict:\n\na = 5.0\nc = \"Hi!\"\nd = Dict{Symbol,Any}()\n@pack! d = a, c\nd # Dict{Symbol,Any}(:a=>5.0,:c=>\"Hi!\")\n\nExample with type:\n\na = 99\nc = \"HaHa\"\nmutable struct A; a; b; c; end\nd = A(4,7.0,\"Hi\")\n@pack! d = a, c\nd.a == 99 #true\nd.c == \"HaHa\" #true\n\nNote that its functionality can be extended by adding methods to the UnPack.pack! function.\n\nTo \"pack\" immutables use the package Setfield.jl.\n\n\n\n\n\n","category":"macro"},{"location":"name/#Customizing-savename-1","page":"Naming Simulations","title":"Customizing savename","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"You can customize savename for your own Types. For example you could make it so that it only uses some specific keys instead of all of them, only specific types, or you could make it access data in a different way (maybe even loading files!). You can even make it have a custom prefix!","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"To do that you may extend any of the following functions:","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"DrWatson.allaccess\nDrWatson.access\nDrWatson.allignore\nDrWatson.default_allowed\nDrWatson.default_prefix\nDrWatson.default_expand","category":"page"},{"location":"name/#DrWatson.allaccess","page":"Naming Simulations","title":"DrWatson.allaccess","text":"allaccess(c)\n\nReturn all the keys c can be accessed using access. For dictionaries/named tuples this is keys(c), for everything else it is fieldnames(typeof(c)).\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.access","page":"Naming Simulations","title":"DrWatson.access","text":"access(c, key)\n\nAccess c with given key. For AbstractDict this is getindex, for anything else it is getproperty.\n\naccess(c, keys...)\n\nWhen given multiple keys, access is called recursively, i.e. access(c, key1, key2) = access(access(c, key1), key2) and so on. For example, if c, c.k1 are NamedTuples then access(c, k1, k2) == c.k1.k2.\n\nnote: Note\nPlease only extend the single key method when customizing access for your own Types.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.allignore","page":"Naming Simulations","title":"DrWatson.allignore","text":"allignore(c) = ()\n\nReturn all the keys c that will be ignored in savename.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_allowed","page":"Naming Simulations","title":"DrWatson.default_allowed","text":"default_allowed(c) = (Real, String, Symbol, TimeType)\n\nReturn the (super-)Types that will be used as allowedtypes in savename.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_prefix","page":"Naming Simulations","title":"DrWatson.default_prefix","text":"default_prefix(c) = \"\"\n\nReturn the prefix that will be used by default in savename.\n\nNotice that if default_prefix is defined for c but a prefix is also given to savename then the two values are merged via joinpath for convenience (if they are not the same of course).\n\nE.g. defining default_prefix(c::MyType) = \"lala\" and calling\n\nsavename(datadir(), mytype)\n\nwill in fact return a string that looks like\n\n\"path/to/data/lala_p1=...\"\n\nThis allows savename to work well with produce_or_load.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_expand","page":"Naming Simulations","title":"DrWatson.default_expand","text":"default_expand(c) = String[]\n\nKeys that should be expanded in their savename within savename. Must be Vector{String} (as all keys are first translated into strings inside savename).\n\n\n\n\n\n","category":"function"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"See Real World Examples for an example of customizing savename. Specifically, have a look at savename and nested containers for a way to","category":"page"},{"location":"name/#Reverse-engineering-savename-1","page":"Naming Simulations","title":"Reverse-engineering savename","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"parse_savename","category":"page"},{"location":"name/#DrWatson.parse_savename","page":"Naming Simulations","title":"DrWatson.parse_savename","text":"parse_savename(filename::AbstractString; kwargs...)\n\nTry to convert a shorthand name produced with savename into a dictionary containing the parameters and their values, a prefix and suffix string. Return prefix, parameters, suffix.\n\nParsing the key-value parts of filename is performed under the assumption that the value is delimited by = and the closest connector. This allows the user to have connector (eg. _) in a key name (variable name) but not in the value part.\n\nKeywords\n\nconnector = \"_\" : string used to connect the various entries.\nparsetypes = (Int, Float64) : tuple used to define the types which should be tried when parsing the values given in filename. Fallback is String.\n\n\n\n\n\n","category":"function"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"EditURL = \"https://github.com/JuliaDynamics/DrWatson.jl/blob/master/docs/src/workflow.jl\"","category":"page"},{"location":"workflow/#DrWatson-Workflow-Tutorial-1","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"cd(@__DIR__)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Disclaimer: DrWatson assumes basic knowledge of how Julia's project manager works.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"This example page demonstrates how DrWatson's functions help a typical scientific workflow, as illustrated below:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"(Image: )","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Blue text comes from DrWatson. Of course, not all of DrWatson's functionality will be highlighted in this tutorial nor is shown in the above figure!","category":"page"},{"location":"workflow/#.-Setup-the-project-1","page":"DrWatson Workflow Tutorial","title":"1. Setup the project","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"So, let's start a new scientific project. You want your project to be contained in a folder. So let's create a new project, located at current working directory","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"using DrWatson\ninitialize_project(\"DrWatson Example\"; authors=\"Datseris\", force=true)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Alright now we have a project set up. The project has a default reasonable structure, as illustrated in the Default Project Setup page:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"using DrWatson\nstruct ShowFile\n    file::String\nend\nfunction Base.show(io::IO, ::MIME\"text/plain\", f::ShowFile)\n    write(io, read(f.file))\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"ShowFile(dirname(pathof(DrWatson))*\"/defaults/project_structure.txt\") # hide","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"For example, folders exist for data, plots, scripts, source code, etc. Three files are noteworthy:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Project.toml: Defines project\nManifest.toml: Contains exact list of project dependencies\n.git (hidden folder): Contains reversible and searchable history of the project","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"The scientific project we have created is also a Julia project environment. This means that it has its own dedicated dependencies and versions of dependencies. This project is now active by default so we can start adding packages that we will be using in the project. We'll add the following for demonstrating","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"using Pkg\nPkg.add([\"Statistics\", \"JLD2\"])","category":"page"},{"location":"workflow/#.-Write-some-scripts-1","page":"DrWatson Workflow Tutorial","title":"2. Write some scripts","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"We start by writing some script for our project that will do some dummy calculations. Let's create scripts/example.jl in our project. All following code is supposed to exist in that file.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"cd(joinpath(@__DIR__, \"DrWatson Example\"))","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Now, with DrWatson every script (typically) starts with the following two lines:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"quickactivate(\"DrWatson Example\", \"DrWatson Example\")","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"using DrWatson\n@quickactivate \"DrWatson Example\" # <- project name","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"This command does something simple: it searches the folder of the script, and its parent folders, until it finds a Project.toml. It activates that project, but if the project name doesn't match the given name (here \"DrWatson Example\") it throws an error. Let's see the project we activated:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"projectname()","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"This is extremely useful for two reasons. First, it is guaranteed that our scripts run within the context of the project and thus use the correct package versions.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Second, DrWatson provides the powerful function projectdir and its derivatives like datadir, plotsdir, srcdir, etc.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"projectdir()","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"projectdir will always return the path to the currently active project. It doesn't matter where its called from, or where the active project actually is. So, by using DrWatson, you don't care anymore where your current script is, you only care about the target directory.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"datadir()","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"datadir(\"sims\", \"electron_gas\")","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Giving arguments to projectdir and derivatives joins paths.","category":"page"},{"location":"workflow/#.-Prepare-simulations-1","page":"DrWatson Workflow Tutorial","title":"3. Prepare simulations","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Let's say we write a simple simulation function, that creates some data","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"function fakesim(a, b, v, method = \"linear\")\n    if method == \"linear\"\n        r = @. a + b * v\n    elseif method == \"cubic\"\n        r = @. a*b*v^3\n    end\n    y = sqrt(b)\n    return r, y\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"and we create some parameters in our scripts and run the simulation","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"a, b = 2, 3\nv = rand(5)\nmethod = \"linear\"\nr, y = fakesim(a, b, v, method)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Okay, that is fine, but it is typically the case that in scientific context some simulations are done for several different combinations of parameters. It is convenient to group all parameters in a dictionary, with the keys being the parameters. Depending on the package you will use to actually save the data, the key type should be either String or Symbol. Here we will be using JLD2.jl and therefore the key type will be String.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"params = @strdict a b v method","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Above we used the ultra-cool @strdict macro, which creates a dictionary from existing variables!","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Now, for every simulation we want to do, we would create such a container. We can use the dict_list to ease up the process of preparing several of these parameter containers","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"allparams = Dict(\n    \"a\" => [1, 2], # it is inside vector. It is expanded.\n    \"b\" => [3, 4],\n    \"v\" => [rand(5)],     # single element inside vector; no expansion\n    \"method\" => \"linear\", # not in vector = not expanded, even if naturally iterable\n)\n\ndicts = dict_list(allparams)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"using dict_list is great, because it has a very clear design on how to expand containers, while not caring whether the parameter values are iterable or not. In short everything in a Vector is expanded once (Vectors of length 1 are not expanded naturally). See dict_list for more details.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"The resulting dictionaries are then typically given into a main or makesim function that actually does the simulation given some input parameters.","category":"page"},{"location":"workflow/#.-Run-and-save-1","page":"DrWatson Workflow Tutorial","title":"4. Run and save","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Alright, we now have to actually save the results, so we first define:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"function makesim(d::Dict)\n    @unpack a, b, v, method = d\n    r, y = fakesim(a, b, v, method)\n    fulld = copy(d)\n    fulld[\"r\"] = r\n    fulld[\"y\"] = y\n    return fulld\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"and then we can save the results by once again leveraging projectdir","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"for (i, d) in enumerate(dicts)\n    f = makesim(d)\n    wsave(datadir(\"simulations\", \"sim_$(i).jld2\"), f)\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"(wsave is a function from DrWatson, that ensures that the directory you try to save the data exists. It then calls FileIO.save)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Here each simulation was named according to a number. But this is not how we do it in science... We typically want the input parameters to be part of the file name. E.g. here we would want the file name to be something like a=2_b=3_method=linear.jld2. It would be also nice that such a naming scheme would apply to arbitrary input parameters so that we don't have to manually write a=$(a)_b=$(b)_method=$(method) and change this code every time we change a parameter name...","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Enter savename:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"savename(params)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"savename takes as an input pretty much any Julia composite container with key-value pairs and transforms it into such a name. We can even do","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"savename(dicts[1], \"jld2\")","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"savename is flexible and smart. As you noticed, even though the vector v with 5 numbers is part of the input, it wasn't included in the name (on purpose). See the savename documentation for more.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"We now transform our make+save loop into","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"for (i, d) in enumerate(dicts)\n    f = makesim(d)\n    wsave(datadir(\"simulations\", savename(d, \"jld2\")), f)\nend\n\nreaddir(datadir(\"simulations\"))","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"That is cool, but we can do better. In fact, much better. Remember that the project initialized by DrWatson is a git repository. So, now we quickly go into git and commit the script we have created and all changes (not shown here).","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Then we make+save again, but now instead of wsave we use @tagsave:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"for (i, d) in enumerate(dicts)\n    f = makesim(d)\n    @tagsave(datadir(\"simulations\", savename(d, \"jld2\")), f; gitpath = \"../..\")\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"for (i, d) in enumerate(dicts)\n    f = makesim(d)\n    @tagsave(datadir(\"simulations\", savename(d, \"jld2\")), f)\nend","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"and let's load the first simulation","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"firstsim = readdir(datadir(\"simulations\"))[1]\n\nwload(datadir(\"simulations\", firstsim))","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"So what happened is that tagsave automatically added git-related information into the file we saved (the field :gitcommit), enabling reproducibility!","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"It gets even better! Because @tagsave is a macro, it deduced automatically where the script that called @tagsave was located. It even includes the exact line of code that called the @tagsave command. This information is in the :script field of the saved data!","category":"page"},{"location":"workflow/#.-Analyze-results-1","page":"DrWatson Workflow Tutorial","title":"5. Analyze results","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Cool, now we can start analyzing some simulations. The actual analysis is your job, but DrWatson can help you get started with the collect_results function. Notice that you need to be using DataFrames to access the function!","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Pkg.add([\"DataFrames\"])\nusing DataFrames\n\ndf = collect_results(datadir(\"simulations\"))","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Some things to note:","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"the returned object is a DataFrame for further analysis.\nthe input to collect_result is a folder, not a dataframe! The function does the loading and combining for you.\nIf you create new simulations, you can iteratively (or all from scratch) add them to this dataframe.\nIf you create new simulations that have new parameters, that don't exist in the simulations already saved, that's no problem. collect_results will appropriately and automatically add missing to all parameter values that don't exist in previews and/or current simulations. This is demonstrated explicitly in the Adapting to new data/parameters real world example, so it is not repeated here.\nSimilarly with e.g. savename, collect_results is a flexible function. It has several configuration options.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"Great! so now we are doing some analysis and we want to save some results... It is very often the case in science that the same analysis may be done again, and again, and some times even with the same parameters... And poor scientitists sometimes forget to change the name of the output file, and end up overwritting previous work! Devastating!","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"To avoid such scenarios, we can use the function safesave, e.g.","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"analysis = 42\n\nsafesave(datadir(\"ana\", \"linear.jld2\"), @strdict analysis)","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"If a file linear.jld2 exists in that folder, it is not overwritten. Instead, it is renamed to linear#1.jld2, and a new linear.jld2 file is made!","category":"page"},{"location":"workflow/#.-Share-your-project-1","page":"DrWatson Workflow Tutorial","title":"6. Share your project","text":"","category":"section"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"This is already discussed in the Reproducibility section of the docs so there is no reason to copy/paste everything here. What is demonstrated there is that it is truly trivial to share your project with a colleague, and this project is guaranteed to work for them!","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"","category":"page"},{"location":"workflow/#","page":"DrWatson Workflow Tutorial","title":"DrWatson Workflow Tutorial","text":"And that's it! We hope that DrWatson will take some stress out of the absurdly stressfull scientific life!","category":"page"},{"location":"run&list/#Running-and-Listing-Simulations-1","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"","category":"section"},{"location":"run&list/#Preparing-Simulation-Runs-1","page":"Running & Listing Simulations","title":"Preparing Simulation Runs","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"It is very often the case that you want to run \"batch simulations\", i.e. just submit a bunch of different simulations, all using same algorithms and code but just different parameters. This scenario always requires the user to prepare a set of simulation parameter containers which are then passed into some kind of \"main\" function that starts the simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"To make the preparation part simpler we provide the following functionality:","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"dict_list\ndict_list_count\n@onlyif","category":"page"},{"location":"run&list/#DrWatson.dict_list","page":"Running & Listing Simulations","title":"DrWatson.dict_list","text":"dict_list(c::Dict)\n\nExpand the dictionary c into a vector of dictionaries. Each entry has a unique combination from the product of the Vector values of the dictionary while the non-Vector values are kept constant for all possibilities. The keys of the entries are the same.\n\nWhether the values of c are iterable or not is of no concern; the function considers as \"iterable\" only subtypes of Vector.\n\nTo restrict some values in the dictionary so that they only appear in the resulting dictionaries, if a certain condition is met, the macro @onlyif can be used on those values.\n\nUse the function dict_list_count to get the number of dictionaries that dict_list will produce.\n\nExamples\n\njulia> c = Dict(:a => [1, 2], :b => 4);\n\njulia> dict_list(c)\n2-element Array{Dict{Symbol,Int64},1}:\n Dict(:a=>1,:b=>4)\n Dict(:a=>2,:b=>4)\n\njulia> c[:model] = \"linear\"; c[:run] = [\"bi\", \"tri\"];\n\njulia> dict_list(c)\n4-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:model=>\"linear\")\n\njulia> c[:e] = [[1, 2], [3, 5]];\n\njulia> dict_list(c)\n8-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.dict_list_count","page":"Running & Listing Simulations","title":"DrWatson.dict_list_count","text":"dict_list_count(c) -> N\n\nReturn the number of dictionaries that will be created by calling dict_list(c).\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.@onlyif","page":"Running & Listing Simulations","title":"DrWatson.@onlyif","text":"@onlyif(ex, value)\n\nTag value to only appear in a dictionary created with dict_list if the Julia expression ex (see below) is evaluated as true.  If value is a subtype of Vector, @onlyif is applied to each entry. Since @onlyif is applied to a value and not to a dictionary key, it is possible to restrict only some of the values of a vector. This means that based on ex the number of options for a particular key varies.\n\nWithin ex it is possible to extract values of the dictionary passed to dict_list by a shorthand notation where only the key must be provided.  For example ex = :(:N == 1) is tranformed in the call dict_list(d) to an expression analogous to :(d[:N] == 1) by using the function lookup_candidate.  This is supported for Symbol and String keys.\n\nExamples\n\njulia> d = Dict(:a => [1, 2], :b => 4, :c => @onlyif(:a == 1, [10, 11]));\n\njulia> dict_list(d) # only in case `:a` is `1` the dictionary will get key `:c`\n3-element Array{Dict{Symbol,Int64},1}:\n Dict(:a => 1,:b => 4,:c => 10)\n Dict(:a => 1,:b => 4,:c => 11)\n Dict(:a => 2,:b => 4)\n\n julia> d = Dict(:a => [1, 2], :b => 4, :c => [10, @onlyif(:a == 1, 11)]);\n\n julia> dict_list(d) # only in case `:a` is `1` the dictionary will get extra value `11` for key `:c`\n 3-element Array{Dict{Symbol,Int64},1}:\n Dict(:a => 1,:b => 4,:c => 10)\n Dict(:a => 1,:b => 4,:c => 11)\n Dict(:a => 2,:b => 4,:c => 10)\n\nSee the Defining parameter sets with restrictions section for more examples.\n\n\n\n\n\n","category":"macro"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"Using the above function means that you can write your \"preparation\" step into a single dictionary and then let it automatically expand into many parameter containers. This keeps the code cleaner but also consistent, provided that it follows one simple rule: Anything that is a Vector has many parameters, otherwise it is one parameter. dict_list considers this true irrespectively of what the Vector contains. This allows users to use any iterable custom type as a single \"parameter\" of a simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"See the Preparing & running jobs for a very convenient application!","category":"page"},{"location":"run&list/#Saving-Temporary-Dictionaries-1","page":"Running & Listing Simulations","title":"Saving Temporary Dictionaries","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"The functionality of dict_list is great, but can fall short in cases of submitting jobs to a computer cluster. For serial clusters, each run is submitted to a different Julia process and thus one cannot propagate a Julia in-memory Dict (for parallel clusters using pmap is fine).","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"To balance this, we have here some simple functionality that stores the result of dict_list (or any other dictionary collection, really) to files with temporary names. The names are returned and can then be propagated into a main-like Julia process that can take the temp-name as an input, load the dictionary and then extract the data.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"tmpsave","category":"page"},{"location":"run&list/#DrWatson.tmpsave","page":"Running & Listing Simulations","title":"DrWatson.tmpsave","text":"tmpsave(dicts::Vector{Dict} [, tmp]; kwargs...) -> r\n\nSave each entry in dicts into a unique temporary file in the directory tmp. Then return the list of file names (relative to tmp) that were used for saving each dictionary. Each dictionary can then be loaded back by calling\n\nFileIO.load(nth_tmpfilename, \"params\")\n\ntmp defaults to projectdir(\"_research\", \"tmp\").\n\nSee also dict_list.\n\nKeywords\n\nl = 8 : number of characters in the random string.\nprefix = \"\" : prefix each temporary name will have.\nsuffix = \"jld2\" : ending of the temporary names (no need for the dot).\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"An example usage is shown in Using a Serial Cluster.","category":"page"},{"location":"run&list/#Collecting-Results-1","page":"Running & Listing Simulations","title":"Collecting Results","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"note: Requires `DataFrames`\nThe function collect_results! is only available if you do using DataFrames in your Julia session.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"There are cases where you have saved a bunch of simulation results in a bunch of different files in a folder. It is useful to be able to collect all of these results into a single table, in this case a DataFrame. The function collect_results! provides this functionality. Importantly, the function is \"future-proof\" which means that it works nicely even if you add new parameters or remove old parameters from your results as your project progresses!","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"collect_results!\ncollect_results","category":"page"},{"location":"run&list/#DrWatson.collect_results!","page":"Running & Listing Simulations","title":"DrWatson.collect_results!","text":"collect_results!([filename,] folder; kwargs...) -> df\n\nSearch the folder (and possibly all subfolders) for new result-files and add them to df which is a DataFrame containing all the information from each result-file. If a result-file is missing keys that are already columns in df, they will be set as missing. If on the other hand new keys are encountered, a new column will be added and filled with missing for all previous entries.\n\nIf no file exists in filename, then df will be saved there. If however filename exists, the existing df will be first loaded and then reused. The reused df has some results already collected: files already included in df are skipped in subsequent calls to collect_results! while new result-files are simply appended to the dataframe.\n\nfilename defaults to:\n\nfilename = joinpath(dirname(folder), \"results_$(basename(folder)).jld2\")\n\nSee also collect_results.\n\nwarning: Warning\ndf contains a column :path which is the path where each result-file is saved to. This is used to not reload and reprocess files already present in df when searching for new ones.If you have an entry :path in your saved result-files this will probably break collect_results (untested).\n\nKeyword Arguments\n\nsubfolders::Bool = false : If true also scan all subfolders of folder for result-files.\nvalid_filetypes = [\".bson\", \".jld\", \".jld2\"]: Only files that have these endings are interpreted as result-files. Other files are skipped.\nrpath = nothing : If not nothing stores relpath(file,rpath) of result-files in df. By default the absolute path is used.\nverbose = true : Print (using @info) information about the process.\nwhite_list : List of keys to use from result file. By default uses all keys from all loaded result-files.\nblack_list = [:gitcommit, :gitpatch, :script]: List of keys not to include from result-file.\nspecial_list = []: List of additional (derived) key-value pairs to put in df as explained below.\n\nspecial_list is a Vector where each entry is a derived quantity to be included in df. There are two types of entries. The first option is of the form key => func where the key is a symbol to be used as column name in the DataFrame. The function entry always takes a single argument, which is the loaded result-file (a dictionary). The second option is to provide just one function func. This function also takes the single dictionary argument but returns one or more key => value pairs. This second notation may be useful when one wants to extract values for multiple columns in a single step. As an example consider that each result-file contains a field :longvector too large to be included in the df. The quantity of interest is the mean and the variance of said field. To have these values in your results first use black_list = [:longvector] and then define\n\nspecial_list = [ :lv_mean => data -> mean(data[:longvector]),\n                 :lv_lar  => data -> var(data[:longvector]) ]\n\nIn case this operation fails the values will be treated as missing.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.collect_results","page":"Running & Listing Simulations","title":"DrWatson.collect_results","text":"collect_results(folder; kwargs...) -> df\n\nDo exactly the same as collect_results! but don't care to load (or later save) an existing dataframe. Thus all found results files are processed.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"For an example of using this functionality please have a look at the Real World Examples page!","category":"page"},{"location":"save/#Saving-Tools-1","page":"Saving Tools","title":"Saving Tools","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"This page discusses numerous tools that can significantly improve process of saving & loading files, always in a scientific context.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"These tools are also used in the examples demonstrated in the Real World Examples page. After reading the proper documentation here it might be worth it to have a look there as well!","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"In DrWatson we save and load files with the functions wsave(filename, data) and wload(filename). These functions are further used in the tools below, like e.g. tagsave and can be overloaded for your own specific datatype.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"In addition, wsave ensures that mkpath is always called on the path you are trying to save your file at. We all know how unpleasant it is to run a 2-hour simulation and save no data because FileIO.save complains that the path you are trying to save at does not exist...","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"To overload the saving part, add a new method to DrWatson._wsave(filename, ::YourType) (notice the _). By overloading _wsave you get all the extra functionality of tagsave, safesave, etc., for free for your own types (tagsave requires that you save your data as a dictionary).","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"warning: Saving and loading fallback\nBy default we fallback to FileIO.save and FileIO.load for and types. This means that you have to install yourself whatever saving backend you want to use. FileIO by itself does not install a package that saves data, it only provides the interface!The suffix of the file name determines which package will be used for actually saving the file. It is your responsibility to know how the saving package works and what input it expects!","category":"page"},{"location":"save/#Safely-saving-data-1","page":"Saving Tools","title":"Safely saving data","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Almost all packages that save data by default overwrite existing files (if given a save name of an existing file). This is the default behavior because often it is desired.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Sometimes it is not though! And the consequences of overwritten data can range from irrelevant to catastrophic. To avoid such an event we provide an alternative way to save data that will never overwrite existing files:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"safesave","category":"page"},{"location":"save/#DrWatson.safesave","page":"Saving Tools","title":"DrWatson.safesave","text":"safesave(filename, data)\n\nSafely save data in filename by ensuring that no existing files are overwritten. Do this by renaming already existing data with a backup-number ending like #1, #2, .... For example if filename = test.jld2, the first time you safesave it, the file is saved normally. The second time the existing save is renamed to test_#1.jld2 and a new file test.jld2 is then saved.\n\nIf a backup file already exists then its backup-number is incremented (e.g. going from #2 to #3). For example safesaving test.jld2 a third time will rename the old test_#1.jld2 to test_#2.jld2, rename the old test.jld2 to test_#1.jld2 and then save a new test.jld2 with the latest data.\n\nSee also tagsave.\n\n\n\n\n\n","category":"function"},{"location":"save/#Tagging-a-run-using-Git-1","page":"Saving Tools","title":"Tagging a run using Git","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"For reproducibility reasons (and also to not go insane when asking \"HOW DID I GET THOSE RESUUUULTS\") it is useful to \"tag\" any simulation/result/process using the Git status of the repository.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"To this end we have some functions that can be used to ensure reproducibility:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"tagsave\n@tagsave","category":"page"},{"location":"save/#DrWatson.tagsave","page":"Saving Tools","title":"DrWatson.tagsave","text":"tagsave(file::String, d::Dict; safe = false, gitpath = projectdir(), storepatch = true, force = false)\n\nFirst tag! dictionary d and then save d in file. If safe = true save the file using safesave.\n\n\"Tagging\" means that when saving the dictionary, an extra field :gitcommit is added to establish reproducibility of results using Git. If the Git repository is dirty, one more field :gitpatch is added that stores the difference string.  If a dictionary already contains a key :gitcommit, it is not overwritten, unless, force=true. For more details, see tag!.\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.@tagsave","page":"Saving Tools","title":"DrWatson.@tagsave","text":"@tagsave(file::String, d::Dict; kwargs...)\n\nSame as tagsave but one more field :script is added that records the local path of the script and line number that called @tagsave, see @tag!.\n\n\n\n\n\n","category":"macro"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"The functions also incorporate safesave if need be.","category":"page"},{"location":"save/#Low-level-functions-1","page":"Saving Tools","title":"Low level functions","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"@tagsave internally uses the following low level functions:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"tag!\n@tag!\ngitdescribe\nDrWatson.gitpatch","category":"page"},{"location":"save/#DrWatson.tag!","page":"Saving Tools","title":"DrWatson.tag!","text":"tag!(d::Dict; gitpath = projectdir(), storepatch = true, force = false) -> d\n\nTag d by adding an extra field gitcommit which will have as value the gitdescribe of the repository at gitpath (by default the project's gitpath). Do nothing if a key gitcommit already exists (unless force=true then replace with the new value) or if the Git repository is not found. If the git repository is dirty, i.e. there are un-commited changes, then the output of git diff HEAD is stored in the field gitpatch.  Note that patches for binary files are not stored.\n\nNotice that the key-type of the dictionary must be String or Symbol. If String is a subtype of the value type of the dictionary, this operation is in-place. Otherwise a new dictionary is created and returned.\n\nTo restore a repository to the state of a particular model-run do:\n\ncheckout the relevant commit with git checkout xyz where xyz is the value stored\napply the patch git apply patch, where the string stored in the gitpatch field needs to be written to the file patch.\n\nExamples\n\njulia> d = Dict(:x => 3, :y => 4)\nDict{Symbol,Int64} with 2 entries:\n  :y => 4\n  :x => 3\n\njulia> tag!(d)\nDict{Symbol,Any} with 3 entries:\n  :y => 4\n  :gitcommit => \"96df587e45b29e7a46348a3d780db1f85f41de04\"\n  :x => 3\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.@tag!","page":"Saving Tools","title":"DrWatson.@tag!","text":"@tag!(d, gitpath = projectdir(), storepatch = true, force = false) -> d\n\nDo the same as tag! but also add another field script that has the path of the script that called @tag!, relative with respect to gitpath. The saved string ends with #line_number, which indicates the line number within the script that @tag! was called at.\n\nExamples\n\njulia> d = Dict(:x => 3)Dict{Symbol,Int64} with 1 entry:\n  :x => 3\n\njulia> @tag!(d) # running from a script or inline evaluation of Juno\nDict{Symbol,Any} with 3 entries:\n  :gitcommit => \"618b72bc0936404ab6a4dd8d15385868b8299d68\"\n  :script => \"test\\stools_tests.jl#10\"\n  :x      => 3\n\n\n\n\n\n","category":"macro"},{"location":"save/#DrWatson.gitdescribe","page":"Saving Tools","title":"DrWatson.gitdescribe","text":"gitdescribe(gitpath = projectdir()) -> gitstr\n\nReturn a string gitstr with the output of git describe if an annotated git tag exists, otherwise the current active commit id of the Git repository present in gitpath, which by default is the currently active project. If the repository is dirty when this function is called the string will end with \"_dirty\".\n\nReturn nothing if gitpath is not a Git repository, i.e. a directory within a git repository.\n\nThe format of the git describe output in general is\n\n`\"TAGNAME-[NUMBER_OF_COMMITS_AHEAD-]gLATEST_COMMIT_HASH[_dirty]\"`\n\nIf the latest tag is v1.2.3 and there are 5 additional commits while the latest commit hash is 334a0f225d9fba86161ab4c8892d4f023688159c, the output will be v1.2.3-5-g334a0f. Notice that git will shorten the hash if there are no ambiguous commits.\n\nMore information about the git describe output can be found on (https://git-scm.com/docs/git-describe)\n\nSee also tag!.\n\nExamples\n\njulia> gitdescribe() # a tag exists\n\"v1.2.3-g7364ab\"\n\njulia> gitdescribe() # a tag doesn't exist\n\"96df587e45b29e7a46348a3d780db1f85f41de04\"\n\njulia> gitdescribe(path_to_a_dirty_repo)\n\"3bf684c6a115e3dce484b7f200b66d3ced8b0832_dirty\"\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.gitpatch","page":"Saving Tools","title":"DrWatson.gitpatch","text":"gitpatch(gitpath = projectdir())\n\nGenerates a patch describing the changes of a dirty repository compared to its last commit; i.e. what git diff HEAD produces. The gitpath needs to point to a directory within a git repository, otherwise nothing is returned.\n\nBe aware that gitpatch needs a working installation of Git, that  can be found in the current PATH.\n\n\n\n\n\n","category":"function"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Please notice that tag! will operate in place only when possible. If not possible then a new dictionary is returned. Also (importantly) these functions will never error as they are most commonly used when saving simulations and this could risk data not being saved!","category":"page"},{"location":"save/#Produce-or-Load-1","page":"Saving Tools","title":"Produce or Load","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"produce_or_load is a function that very conveniently integrates with savename to either load a file if it exists, or if it doesn't to produce it, save it and then return it!","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"This saves you the effort of checking if a file exists and then loading, or then running some code and saving, or writing a bunch of if clauses in your code. In addition, it attempts to minimize computing energy spent on getting a result.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"produce_or_load","category":"page"},{"location":"save/#DrWatson.produce_or_load","page":"Saving Tools","title":"DrWatson.produce_or_load","text":"produce_or_load([path=\"\",] c, f; kwargs...) -> file, s\n\nLet s = joinpath(path, savename(prefix, c, suffix)). If a file named s exists then load it and return it, along with the global path that it is saved at (s).\n\nIf the file does not exist then call file = f(c), with f your function that produces your data. Then save file as s and then return file, s. The function f must return a dictionary, the macros @dict and @strdict can help with that.\n\nYou can use do-block instead of defining a function to pass in. For example,\n\nproduce_or_load([path=\"\",] c) do c\n    # simulation wiht config `c` runs here\nend\n\nKeywords\n\ntag = true : Save the file using tagsave.\ngitpath, storepatch : Given to tagsave if tag is true.\nsuffix = \"jld2\", prefix = default_prefix(c) : Used in savename.\nforce = false : If true then don't check if file s exists and produce it and save it anyway.\nloadfile = true : If false, this function does not actually load the file, but only checks if it exists. The return value in this case is always nothing, s, regardless of whether the file exists or not. If it doesn't exist it is still produced and saved.\nverbose = true : print info about the process, if the file doesn't exist.\nkwargs... : All other keywords are propagated to savename.\n\nSee also savename.\n\n\n\n\n\n","category":"function"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"See Stopping \"Did I run this?\" for an example usage of produce_or_load.","category":"page"},{"location":"save/#Converting-a-struct-to-a-dictionary-1","page":"Saving Tools","title":"Converting a struct to a dictionary","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"savename gives great support for getting a name out of any Julia composite type. To save something though, one needs a dictionary. So the following function can be conveniently used to directly save a struct using any saving function:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"struct2dict\nstruct2ntuple","category":"page"},{"location":"save/#DrWatson.struct2dict","page":"Saving Tools","title":"DrWatson.struct2dict","text":"struct2dict(s) -> d\n\nConvert a Julia composite type s to a dictionary d with key type Symbol that maps each field of s to its value. This can be useful in e.g. saving:\n\ntagsave(savename(s), struct2dict(s))\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.struct2ntuple","page":"Saving Tools","title":"DrWatson.struct2ntuple","text":"struct2ntuple(s) -> n\n\nConvert a Julia composite type s to a NamedTuple n.\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: DrWatson)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson is a scientific project assistant software. It helps people manage their scientific projects (or any project for that matter).","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Specifically, it is a Julia package created to help people increase the consistency of their scientific projects, navigate them and share them faster and easier, manage scripts, existing simulations as well as project source code. DrWatson helps establishing reproducibility, and in general it makes managing a scientific project a simple job.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"See the Functionality section to get an impression of what you can do with DrWatson or see the DrWatson Workflow Tutorial to get a \"crash course\" of how DrWatson helps the typical scientific workflow. The Description of DrWatson section describes the design decisions that make it a unique software that truly helps the scientific workflow. Or, you can watch this 8-minutes video that introduces DrWatson in JuliaCon2020:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"<iframe width=\"560\" height=\"315\" src=\"https://www.youtube-nocookie.com/embed/jKATlEAu8eE\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"To install, simply type ] add DrWatson in your Julia session. DrWatson is part of JuliaDynamics, check out our website for more cool stuff!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"note: Star us on GitHub!\nIf you like DrWatson the please consider starring the GitHub repository. This gives as an accurate lower bound of the number of people the software has helped!","category":"page"},{"location":"#Rationale-1","page":"Introduction","title":"Rationale","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Have you thought things like:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Urgh, I moved my folders and now my load commands don't work anymore!\nHold on, haven't I run this simulation already?\nDo I have to produce a dataframe of my finished simulations AGAIN?!\nWait, are those experiments already processed?\nPFfffff I am tired of typing savename = \"w=$w_f=$f_x=$x.txt\", can't I do it automatically?\nI wish I could just make a dataframe out of all my simulations with one command!\nYeah you've sent me your project but none of the scripts work...\nIt would be so nice to automatically integrate git information to all the data I save...","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson tries to eradicate such bad thoughts and bedtime nightmares.","category":"page"},{"location":"#Functionality-1","page":"Introduction","title":"Functionality","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson is a scientific project assistant software. Here is what it can do:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Project Setup : A universal project structure and functions that allow you to consistently and robustly navigate through your project, no matter where it is located.\nNaming Simulations : A robust and deterministic scheme for naming and handling your containers.\nSaving Tools : Tools for safely saving and loading your data, tagging the Git commit ID to your saved files, safety when tagging with dirty repos, and more.\nRunning & Listing Simulations: Tools for producing tables of existing simulations/data, adding new simulation results to the tables, preparing batch parameter containers, and more.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"See the DrWatson Workflow Tutorial page to get a quick overview over all of these functionalities.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Think of these core aspects of DrWatson as independent islands connected by bridges. If you don't like the approach of one of the islands, you don't have to use it to take advantage of DrWatson!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Applications of DrWatson are demonstrated the Real World Examples page. All of these examples are taken from code of real scientific projects that use DrWatson.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please note that DrWatson is not a data management system. It is also not a Julia package creator like PkgTemplates.jl nor a package development tool.","category":"page"},{"location":"#Description-of-DrWatson-1","page":"Introduction","title":"Description of DrWatson","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson follows these simple principles:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Non-Invasive. DrWatson does not require you to follow strict rules or change the way you work and do science in order to use it. In addition DrWatson is function-based: you only have to call a function and everything else just works; you do not have to create additional special struct or other data types. In addition, you also do not have to do anything outside of your code (e.g. command line arguments or external software tools).\nSimple. The functionality offered is a baseline from where you handle your project as you wish. This makes it more likely to be of general use but also means that you don't have to \"study\" to learn DrWatson: all concepts are simple, everything is easy to understand.\nConsistent. The functionality is identical across all projects and DrWatson offers a universal base project structure.\nAllows increments. You didn't plan your project well enough? Want to add more folders, more files, more variables to your simulations? It's fine.\nReproducibility. DrWatson aims to make your projects fully reproducible using Git, Julia's package manager and consistent naming schemes.\nModular. DrWatson has a flexible modular design (see Functionality) which means you only have to use what fits your project.\nGeneral. DrWatson is completely agnostic to the content of your project. It is not tailored to specific scientific workflows, or specific scientific communities.\nScientific. DrWatson has been beta tested in many real-world scientific projects and has matured based on feedback from scientists.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This is why we believe DrWatson can help you focus on the science and not worry about project code management.","category":"page"},{"location":"#Citation-1","page":"Introduction","title":"Citation","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you have used DrWatson in a scientific project that lead to a publication, we'd appreciate you citing the paper associated with it:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"@article{Datseris2020,\n  doi = {10.21105/joss.02673},\n  url = {https://doi.org/10.21105/joss.02673},\n  year = {2020},\n  publisher = {The Open Journal},\n  volume = {5},\n  number = {54},\n  pages = {2673},\n  author = {George Datseris and Jonas Isensee and Sebastian Pech and Tamás Gál},\n  title = {DrWatson: the perfect sidekick for your scientific inquiries},\n  journal = {Journal of Open Source Software}\n}","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"or use the DOI directly:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: DOI)","category":"page"},{"location":"#Other-useful-packages-1","page":"Introduction","title":"Other useful packages","text":"","category":"section"},{"location":"#Running-simulations-1","page":"Introduction","title":"Running simulations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/baggepinnen/Hyperopt.jl","category":"page"},{"location":"#Efficient-code-writing-1","page":"Introduction","title":"Efficient code writing","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/mauro3/Parameters.jl\nhttps://github.com/docopt/DocOpt.jl\nhttps://github.com/vtjnash/Glob.jl","category":"page"},{"location":"#Notebooks-1","page":"Introduction","title":"Notebooks","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/JuliaLang/IJulia.jl\nhttps://github.com/JunoLab/Weave.jl\nhttps://github.com/fonsp/Pluto.jl","category":"page"},{"location":"#Documenting-your-code-1","page":"Introduction","title":"Documenting your code","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/JuliaDocs/Documenter.jl\nhttps://github.com/fredrikekre/Literate.jl\nhttps://github.com/caseykneale/Sherlock.jl\nhttps://github.com/miguelraz/DoctorDocstrings.jl ","category":"page"},{"location":"#Paper-related-1","page":"Introduction","title":"Paper-related","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/Azzaare/Bibliography.jl","category":"page"},{"location":"#Debugging,-writing-code-1","page":"Introduction","title":"Debugging, writing code","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://junolab.org/\nhttps://github.com/timholy/Revise.jl\nhttps://github.com/JuliaDebug/Debugger.jl","category":"page"},{"location":"#Performance-measures-1","page":"Introduction","title":"Performance measures","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/JuliaCI/BenchmarkTools.jl\nhttps://github.com/timholy/ProgressMeter.jl\nhttps://github.com/KristofferC/TimerOutputs.jl\nhttps://github.com/JuliaDebug/Cthulhu.jl\nProfileViews.jl (similar available in Juno with @profiler)","category":"page"},{"location":"#Saving-Data-1","page":"Introduction","title":"Saving Data","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"BSON.jl\nJLD2.jl\nCSV.jl","category":"page"},{"location":"#Data-management-and-data-bases-1","page":"Introduction","title":"Data management & data bases","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/helgee/RemoteFiles.jl\nhttps://github.com/JuliaDynamics/CaosDB.jl\nhttps://juliadb.org/\nhttps://github.com/SebastianM-C/StorageGraphs.jl","category":"page"},{"location":"#Tabular-data-1","page":"Introduction","title":"Tabular data","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://juliadata.github.io/DataFrames.jl/stable/\nhttps://www.queryverse.org/","category":"page"},{"location":"#Traversing-folders-1","page":"Introduction","title":"Traversing folders","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Base.Filesystem\nhttps://github.com/Keno/AbstractTrees.jl/blob/master/examples/fstree.jl","category":"page"},{"location":"#Time-management-1","page":"Introduction","title":"Time management","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/oxinabox/ProjectManagement.jl","category":"page"},{"location":"#Support-and-Contributing-1","page":"Introduction","title":"Support and Contributing","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Questions about DrWatson can be asked by directly opening up an Issue on its GitHub page, or asking in the Julia slack channels #helpdesk, #dynamics-bridged.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"If you wish to contribute, thats great! Please consult the online guidelines.","category":"page"},{"location":"#Inspirations-1","page":"Introduction","title":"Inspirations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Initial inspirations for DrWatson follow below. All inspirations are specific in scope and functionality, and since its original conception DrWatson has moved on to become a whole scientific project assistant.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://drivendata.github.io/cookiecutter-data-science/#cookiecutter-data-science","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://discourse.julialang.org/t/computational-experiments-organising-different-algorithms-their-parameters-and-results/10774/7","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"http://neuralensemble.org/sumatra/","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/mohamed82008/ComputExp.jl","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://sacred.readthedocs.io/en/latest/index.html","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://experimentator.readthedocs.io/en/latest/","category":"page"}]
}
