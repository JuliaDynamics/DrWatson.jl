var documenterSearchIndex = {"docs":
[{"location":"project/#Project-Setup-1","page":"Project Setup","title":"Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Part of the functionality of DrWatson is creating and navigating through a project setup consistently. This works even if you move your project to a different location/computer or send it to a colleague with a different Julia installation. In addition, the navigation process is identical across any project that uses DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This can \"just work\" (TM) because of the following principles:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Your science project is also a Julia project defined by a Project.toml file. This way the project tracks the used packages (and their versions) and can be shared with any other Julia user.\nYou first activate this project environment before running any code. This way you ensure that your project runs on the specified package installation (instead of the global one). See Activating a Project for ways to do this.\nYou use the functions projectdir, datadir, etc. from DrWatson to navigate your project (see Navigating a Project).","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Importantly, our suggested project setup was designed to be fully reproducible, see Reproducibility.","category":"page"},{"location":"project/#Default-Project-Setup-1","page":"Project Setup","title":"Default Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"DrWatson suggests a universal project structure for any scientific project, which is the following:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"using DrWatson\nstruct ShowFile\n    file::String\nend\nfunction Base.show(io::IO, ::MIME\"text/plain\", f::ShowFile)\n    write(io, read(f.file))\nend","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"ShowFile(dirname(pathof(DrWatson))*\"/defaults/project_structure.txt\") # hide","category":"page"},{"location":"project/#src-vs-scripts-1","page":"Project Setup","title":"src vs scripts","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Seems like src and scripts folders have pretty similar functionality. However there is a distinction between these two. You can follow these mental rules to know where to put file.jl:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If upon include(\"file.jl\") there is anything being produced, be it data files, plots or even output to the console, then it should be in scripts.\nIf it is functionality used across multiple files or pipelines, it should be in src.\nsrc should only contain files that define functions or types but not output anything. You can also organize src to be a Julia package, or contain multiple Julia packages.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that it is typically the case that in the src folder you will have a full Julia package as a subfolder. In such cases be sure that you add the relative path to the package in your Manifest.toml, instead of the absolute path. This will ensure reproducibility!","category":"page"},{"location":"project/#Initializing-a-Project-1","page":"Project Setup","title":"Initializing a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To initialize a project as described in the Default Project Setup section, we provide the following function:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"initialize_project","category":"page"},{"location":"project/#DrWatson.initialize_project","page":"Project Setup","title":"DrWatson.initialize_project","text":"initialize_project(path [, name]; kwargs...)\n\nInitialize a scientific project expected by DrWatson inside the given path. If its name is not given, it is assumed to be the folder's name.\n\nThe new project remains activated for you to immidiately add packages.\n\nKeywords\n\nreadme = true : adds a README.md file.\nauthors = nothing : if a string or container of strings, adds the authors in the Project.toml file.\nforce = false : If the path is not empty then throw an error. If however force is true then recursively delete everything in the path and create the project.\ngit = true : Make the project a Git repository.\n\n\n\n\n\n","category":"function"},{"location":"project/#Including-Julia-packages-in-src-1","page":"Project Setup","title":"Including Julia packages in src","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that the project initialized by DrWatson does not represent a Julia package. It represents a scientific project. That being said, it is often the case that you want to develop normal Julia Modules inside your project, so that you can later use them in your code with using PackageName. The proper way to do this is to initialize Julia packages, using the package manager, inside the src folder, using these steps:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Active your project that uses DrWatson.\nChange directory to the project's src folder.\nGo into package mode and initialize a package with the name that you want: generate PackageName\ndev the local path to PackageName using the package manager , e.g. dev PackageName. Notice that this command uses a local path, see this PR for more details: https://github.com/JuliaLang/Pkg.jl/pull/1215","category":"page"},{"location":"project/#Activating-a-Project-1","page":"Project Setup","title":"Activating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This part of DrWatson's functionality requires you to have your scientific project (and as a consequence, the Julia project) activated. This can be done in multiple ways:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"doing Pkg.activate(\"path/to/project\") programmatically\nusing the startup flag --project path when starting Julia\nby setting the JULIA_PROJECT environment variable\nusing the functions quickactivate and findproject offered by DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"We recommend the fourth approach, although it does come with a caveat (see the docstring of quickactivate).","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"quickactivate\n@quickactivate\nfindproject","category":"page"},{"location":"project/#DrWatson.quickactivate","page":"Project Setup","title":"DrWatson.quickactivate","text":"quickactivate(path [, name::String])\n\nActivate the project found by recursively searching the path and its parents for a valid Julia project file. Optionally check if name is the same as the activated project's name. If it is not, throw an error. See also [@quickactivate]. Do nothing if the project found is already active, or if no project file is found.\n\nExample:\n\nusing DrWatson\nquickactivate(\"path/to/project\", \"Best project in the WOLRLDD\")\n\nNotice that this function is first activating the project and then checking if it matches the name.\n\nwarning: Warning\nNote that to access quickactivate you need to be using DrWatson. For this to be possible DrWatson must be already added in the existing global environment. The version of DrWatson loaded therefore will be the one of the global environment, and not of the activated project. To avoid unexpected behavior take care so that these two versions coincide.In addition please be very careful to write:using DrWatson\nquickactivate(@__DIR__)\nusing Package1, Package2\n# do stuffinstead of the erroneous:using DrWatson, Package1, Package2\nquickactivate(@__DIR__)\n# do stuffThis ensures that the packages you use will all have the versions dictated by your activated project (besides DrWatson, since this is impossible to do using quickactivate).\n\n\n\n\n\n","category":"function"},{"location":"project/#DrWatson.@quickactivate","page":"Project Setup","title":"DrWatson.@quickactivate","text":"@quickactivate\n\nEquivalent with quickactivate(@__DIR__).\n\n@quickactivate name\n\nEquivalent with quickactivate(@__DIR__, name).\n\n\n\n\n\n","category":"macro"},{"location":"project/#DrWatson.findproject","page":"Project Setup","title":"DrWatson.findproject","text":"findproject(path = pwd()) -> project_path\n\nRecursively search path and its parents for a valid Julia project file (anything in Base.project_names). If it is found return its path, otherwise issue a warning and return nothing.\n\nThe function stops searching if it hits either the home directory or the root directory.\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that to get the current project's name you can use:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectname","category":"page"},{"location":"project/#DrWatson.projectname","page":"Project Setup","title":"DrWatson.projectname","text":"projectname()\n\nReturn the name of the currently active project.\n\n\n\n\n\n","category":"function"},{"location":"project/#Navigating-a-Project-1","page":"Project Setup","title":"Navigating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To be able to navigate the project consistently, DrWatson provides the core function","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectdir","category":"page"},{"location":"project/#DrWatson.projectdir","page":"Project Setup","title":"DrWatson.projectdir","text":"projectdir()\n\nReturn the directory of the currently active project.\n\nprojectdir(args...) = joinpath(projectdir(), args...)\n\nJoin the path of the currently active project with args (typically other subfolders).\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Besides the above, the following derivative functions","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"datadir()\nsrcdir()\nplotsdir()\nscriptsdir()\npapersdir()","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"behave exactly like projectdir but have as root the appropriate subdirectory. These are also defined due to the frequent use of these subdirectories.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"All of these functions take advantage of joinpath, ensuring an error-free path creation that works across different operating systems. It is heavily advised to use projectdir and derivatives by giving them the subpaths as arguments, instead of using multiplication between paths:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"datadir(\"foo\", \"test.bson\") # preferred\ndatadir() * \"/foo/test.bson\" # not recommended","category":"page"},{"location":"project/#Reproducibility-1","page":"Project Setup","title":"Reproducibility","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"The project setup approach that DrWatson suggests is designed to work flawlessly with Julia standards, to be easy to share and to be fully reproducible. There are three reasons that true reproducibility is possible:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"The project's used packages are embedded in the project because of Manifest.toml\nThe navigation around the folders of the project uses local directories.\nThe project is a Git repository, which means that it has a detailed (and re-traceable) history of all changes and additions.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If you send your entire project folder to a colleague, they only need to do:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"julia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"to use your project (assuming of course that you are both using the same Julia installation and version). All required packages and dependencies will be installed and then any script that was running in your computer will also be running in their computer in the same way!","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"In addition, with DrWatson you have the possibility of \"tagging\" each simulation created with the commit id, see the discussion around current_commit and tag!. This way, any data result obtained at any moment can be truly reproduced simply by resetting the Git tree to the appropriate commit and running the code.","category":"page"},{"location":"real_world/#Real-World-Examples-1","page":"Real World Examples","title":"Real World Examples","text":"","category":"section"},{"location":"real_world/#Easy-local-directories-1","page":"Real World Examples","title":"Easy local directories","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"I setup all my science projects using DrWatson's suggested setup, using initialize_project. Then, every file in every project has a start that looks like this:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"MagneticBilliardsLyapunovs\")\nusing DynamicalBilliards, PyPlot, LinearAlgebra\n\ninclude(srcdir(\"plot_perturbationgrowth.jl\"))\ninclude(srcdir(\"unitcells.jl\"))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In all projects I save data/plots using datadir/plotdir:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"@tagsave(datadir(\"mushrooms, \"Λ_N=$N.bson\"), (@dict Λ Λσ ws hs description))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The advantage of this approach is that it will always work regardless of if I move the specific file to a different subfolder (which is very often necessary) or whether I move the entire project folder somewhere else! Please be sure you have understood the caveat of using quickactivate!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example from another project. You will notice that another advantage is that I can use identical syntax to access the data or source folders even though I have different projects!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"EmbeddingResearch\")\nusing Parameters\nusing TimeseriesPrediction, LinearAlgebra, Statistics\n\ninclude(srcdir(\"systems\", \"barkley.jl\"))\ninclude(srcdir(\"nrmse.jl\")\n\n# stuff...\n\nsave(datadir(\"sim\", \"barkley\", \"astonishing_results.bson\"), data)","category":"page"},{"location":"real_world/#savename-and-tagging-1","page":"Real World Examples","title":"savename and tagging","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The combination of using savename and tagsave makes it easy and fast to save output in a way that is consistent, robust and reproducible. Here is an example from a project:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"EmbeddingResearch\")\nusing TimeseriesPrediction, LinearAlgebra, Statistics\ninclude(srcdir(\"systems\", \"barkley.jl\"))\n\nΔTs = [1.0, 0.5, 0.1] # resolution of the saved data\nNs = [50, 150] # spatial extent\nfor N ∈ Ns, ΔT ∈ ΔTs\n    T = 10050 # we can offset up to 1000 units\n    every = round(Int, ΔT/barkley_Δt)\n    seed = 1111\n\n    simulation = @ntuple T N ΔT seed\n    U, V = barkley(T, N, every; seed = seed)\n\n    @tagsave(\n        datadir(\"sim\", \"bk\", savename(simulation, \"bson\")),\n        @dict U V simulation\n    )\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This saves files that look like:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"path/to/project/data/sim/bk_N=50_T=10050_seed=1111_ΔT=1.bson","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and each file is a dictionary that has my data fields: :U, :V, :simulation, but also :gitcommit, :script. When I read this file I know exactly what was the source code that produced it (provided that I am not sloppy and commit code changes regularly :P).","category":"page"},{"location":"real_world/#Customizing-savename-1","page":"Real World Examples","title":"Customizing savename","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a simple example for customizing savename. We are using a common struct Experiment across different experiments with cats and mice. In this example we are also using Parameters.jl for a convenient default constructor.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We first define the relevant types.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson, Parameters, Dates\n\n# Define a type hierarchy we use at experiments\nabstract type Species end\nstruct Mouse <: Species end\nstruct Cat <: Species end\n\n# @with_kw comes from Parameters.jl\n@with_kw struct Experiment{S<:Species}\n    n::Int = 50\n    c::Float64 = 10.0\n    x::Float64 = 0.2\n    date::Date = Date(Dates.now())\n    species::S = Mouse()\n    scientist::String = \"George\"\nend\n\ne1 = Experiment()\ne2 = Experiment(species = Cat())","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For analyzing our experiments we need information about the species used, and to use multiple dispatch latter on we decided to make this information associated with a Type. This is why we defined Species.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, we want to customize savename. We start by extending DrWatson.default_prefix:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_prefix(e::Experiment) = \"Experiment_\"*string(e.date)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"However this is not good enough for us, as the information about the species is not contained in savename. We have to extend DrWatson.default_allowed like so:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_allowed(::Experiment) = (Real, String, Species)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"To make printing better we can extend Base.string, which is what DrWatson uses internally in savename to display values.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Base.string(::Mouse) = \"mouse\"\nBase.string(::Cat) = \"cat\"\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Lastly, let's say that the information of which scientist performed the experiment is not really relevant for savename. We can extend the last method, DrWatson.allaccess:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.allaccess(::Experiment) = (:n, :c, :x, :species)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"so that only those four fields will be used (notice that the date field is already used in default_prefix). We finally have:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"println( savename(e1) )\nprintln( savename(e2) )","category":"page"},{"location":"real_world/#savename-and-nested-containers-1","page":"Real World Examples","title":"savename and nested containers","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In the case of user-defined structs and projects of significant complexity, it is often necessary that your \"main\" container has other containers as subfields. savename can adapt to these situations as well. Consider the following example, where I need a core struct that represents a spatio temporal system, and its simulation:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"struct SpatioTemporalSystem\n    model::String # system codeword\n    N        # Integer or Tuple of integers: spatial extent\n    Δt::Real # sampling time in real time units\n    p        # parameters. nothing or Dict{Symbol}\nend\nconst STS = SpatioTemporalSystem\n\nstruct SpatioTemporalTimeseries\n    sts::STS\n    T::Int       # total frame amount\n    ic           # initial condition (matrix, string, seed)\n    fields::Dict # resulting timeseries, dictionary of string to vector\nend\nconst STT = SpatioTemporalTimeseries","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For my use case, p can be nothing or it can be a dictionary itself, containing the possible parameters the spatiotemporal systems can have. To adapt savename to situations like this, we use the functionality surrounding DrWatson.default_expand.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Expanding the necessary methods allows me to do:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.allaccess(c::STS) = (:N, :Δt, :p)\nDrWatson.default_prefix(c::STS) = c.model\nDrWatson.default_allowed(c::STS) = (Real, Tuple, Dict, String)\nDrWatson.default_expand(c::STS) = [\"p\"]\n\nbk = STS(\"barkley\", 60, 0.1, nothing)\nsavename(bk)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and when I do want to use different parameters than the default:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"a = 0.3; b = 0.5\nbk = STS(\"barkley\", 60, 0.1, @dict a b)\nsavename(bk)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Expanding to the second struct is also fine:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_prefix(c::STT) = savename(c.sts)\nstt = STT(bk, 1000, nothing, Dict(\"U\"=>rand(100), \"V\"=>rand(100)))\nsavename(stt)","category":"page"},{"location":"real_world/#Stopping-\"Did-I-run-this?\"-1","page":"Real World Examples","title":"Stopping \"Did I run this?\"","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It can become very tedious to have a piece of code that you may or may not have run and may or may not have saved the produced data. You then constantly ask yourself \"Did I run this?\". Typically one uses isfile and an if clause to either load a file or run some code. Especially in the cases where the code takes only a couple of minutes to finish you are left in a dilemma \"Is it even worth it to save?\".","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This is the dilemma that produce_or_load resolves. You can wrap your code in a function and then produce_or_load will take care of the rest for you! I found it especially useful in scripts that generate figures for a publication.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example; originally I had this piece of code:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"HTEST = 0.1:0.1:2.0\nWS = [0.5, 1.0, 1.5]\nN = 10000; T = 10000.0\n\ntoypar_h = [[] for l in HS]\nfor (wi, w) in enumerate(WS)\n    println(\"w = $w\")\n    for h in HTEST\n        toyp = toyparameters(h, w, N, T)\n        push!(toypar_h[wi], toyp)\n    end\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"that was taking some minutes to run. To use the function produce_or_load I first have to wrap this code in a high level function like so:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"function g(d)\n    HTEST = 0.1:0.1:2.0\n    WS = [0.5, 1.0, 1.5]\n    @unpack N, T = d\n    toypar_h = [[] for l in HS]\n\n    for (wi, w) in enumerate(WS)\n        println(\"w = $w\")\n        for h in HTEST\n            toyp = toyparameters(h, w, N, T)\n            push!(toypar_h[wi], toyp)\n        end\n    end\n    return @dict toypar_h\nend\n\nN = 2000; T = 2000.0\nfile = produce_or_load(\n    datadir(\"mushrooms\", \"toy\"), # path\n    @dict(N, T), # container\n    g, # function\n    prefix = \"fig5_toyparams\" # prefix for savename\n)\n@unpack toypar_h = file","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, every time I run this code block the function tests automatically whether the file exists. Only if it does not, then the code is run while the new result is saved to ensure I won't have to run it again.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The extra step is that I have to extract the useful data I need from the container file. Thankfully the @unpack macro from Parameters.jl makes this super easy.","category":"page"},{"location":"real_world/#Preparing-and-running-jobs-1","page":"Real World Examples","title":"Preparing & running jobs","text":"","category":"section"},{"location":"real_world/#Preparing-the-dictionaries-1","page":"Real World Examples","title":"Preparing the dictionaries","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a shortened script from a project that uses dict_list:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\n\ngeneral_args = Dict(\n    \"model\" => [\"barkley\", \"kuramoto\"],\n    \"noise\" => 0.075,\n    \"noisy_training\" => [true, false],\n    \"N\" => [100],\n    \"embedding\" => [ #(γ, τ, r, c)\n    (4, 5, 1, 0.34), (4, 6, 1, 0.28)]\n)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nprintln(\"Total dictionaries made: \", length(dicts))\ndicts[1]","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, how you use these dictionaries is up to you. Typically each dictionary is given to a main-like Julia function which extracts the necessary data and calls the necessary functions.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Let's say I have written a function that takes in one of these dictionaries and saves the file somewhere locally:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"function cross_estimation(data)\n    γ, τ, r, c = data[\"embedding\"]\n    N = data[\"N\"]\n    # add fake results:\n    data[\"x\"] = rand()\n    data[\"error\"] = rand(10)\n    # Save data:\n    prefix = datadir(\"results\", data[\"model\"])\n    get(data, \"noisy_training\", false) && (prefix *= \"_noisy\")\n    get(data, \"symmetric_training\", false) && (prefix *= \"_symmetric\")\n    sname = savename((@dict γ τ r c N), \"bson\")\n    mkpath(datadir(\"results\", data[\"model\"]))\n    save(datadir(\"results\", data[\"model\"], sname), data)\n    return true\nend","category":"page"},{"location":"real_world/#Using-map-and-pmap-1","page":"Real World Examples","title":"Using map and pmap","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"One way to run many simulations is with map (identical process for using pmap). To run all my simulations I just do:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nmap(cross_estimation, dicts) # or pmap\n\n# load one of the files to be sure everything is ok:\nfilename = readdir(datadir(\"results\", \"barkley\"))[1]\nfile = load(datadir(\"results\", \"barkley\", filename))","category":"page"},{"location":"real_world/#Using-a-Serial-Cluster-1","page":"Real World Examples","title":"Using a Serial Cluster","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In case that I can't store the results of dict_list in memory, I have to change my approach and load them from disk. This is easy with the function tmpsave.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Instead of using Julia to run all jobs from one process with map/pmap one can use Julia to submit many jobs to a cluster que. For our example above, the Julia program that does this would look like this:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nres = tmpsave(dicts)\nfor r in res\n    submit = `qsub -q queuename julia runjob.jl $r`\n    run(submit)\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now the file runjob.jl would have contents that look like:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"f = ARGS[1]\ndict = load(projectdir(\"_research\", \"tmp\", f))\ncross_estimation(dict)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"i.e. it just loads the dict and straightforwardly uses the \"main\" function cross_estimation. Remember to routinely clear the tmp directory! You could do that by e.g. adding a line rm(projectdir(\"_research\", \"tmp\", f) at the end of the runjob.jl script.","category":"page"},{"location":"real_world/#Listing-completed-runs-1","page":"Real World Examples","title":"Listing completed runs","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Continuing from the Preparing & running jobs section, we now want to collect the results of all these simulations into a single DataFrame. We will do that with the function collect_results!.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It is quite simple actually! But because we don't want to include the error, we have to black-list it:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DataFrames # this is necessary to access collect_results!\nbl = [\"error\"]\nres = collect_results!(datadir(\"results\"); black_list = bl, subfolders = true)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We can take also advantage of the basic processing functionality of collect_results! to use the excluded \"error\" column, replacing it with its average value:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using Statistics: mean\nspecial_list = [:avrg_error => data -> mean(data[\"error\"])]\nres = collect_results(\n      datadir(\"results\"),\n      black_list = bl,\n      special_list = special_list,\n      subfolders = true\n)\n\nselect!(res, Not(:path)) # don't show path this time","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As you see here we used collect_results instead of the in-place version, since there already exists a DataFrame with all results processed (and thus everything would be skipped).","category":"page"},{"location":"real_world/#Adapting-to-new-data/parameters-1","page":"Real World Examples","title":"Adapting to new data/parameters","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We once again continue from the above example. But we no we need to run some new simulations with some new parameters that do not exist in the old simulations... Well, DrWatson says \"no problem!\" :)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Let's save these new parameters in a different subfolder, to have a neatly organized project:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"general_args_new = Dict(\n    \"model\" => [\"bocf\"],\n    \"symmetry\" => \"radial\",\n    \"symmetric_training\" => [true, false],\n    \"N\" => [100],\n    \"embedding\" => [ #(γ, τ, r, c)\n    (4, 5, 1, 0.34), (4, 6, 1, 0.28)]\n)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"As you can see, there here there are two parameters not existing in previous simulations, namely \"symmetry\", \"symmetric_training\". In addition, the parameters \"noise\", \"noisy_training\" that existed in the previous simulations do not exist in the current one.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"No problem though, let's run the new simulations:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args_new)\nmap(cross_estimation, dicts)\n\n# load one of the files to be sure everything is ok:\nfilename = readdir(datadir(\"results\", \"bocf\"))[1]\nfile = load(datadir(\"results\", \"bocf\", filename))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Alright, now we want to add these new runs to our existing dataframe that has collected all previous results. This is straight-forward:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"res = collect_results!(datadir(\"results\"); black_list = bl, subfolders = true)\n\nselect!(res, Not(:path)) # don't show path this time","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"All missing entries were adjusted automatically :)","category":"page"},{"location":"name/#Naming-Simulations-1","page":"Naming Simulations","title":"Naming Simulations","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Here we overview functionality that helps you quickly produce containers of parameters and name them using a consistent and intuitive naming scheme.","category":"page"},{"location":"name/#Naming-Schemes-1","page":"Naming Simulations","title":"Naming Schemes","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"A robust naming scheme allows you to create quick names for simulations, create lists of simulations, check existing simulations, etc. More importantly it allows you to easily create simulation-based names consistently and deterministically.","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"This is what the function savename does. Of course, you don't have to use it only for using names to save files. You could use it for anything that fits you (like e.g. adding identifiers to tabular data). savename is also surprisingly useful for creating titles of figures, e.g. savename(c; connector = \", \").","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"savename","category":"page"},{"location":"name/#DrWatson.savename","page":"Naming Simulations","title":"DrWatson.savename","text":"savename([prefix,], c [, suffix]; kwargs...)\n\nCreate a shorthand name, commonly used for saving a file or as a figure title, based on the parameters in the container c (Dict, NamedTuple or any other Julia composite type, e.g. created with Parameters.jl). If provided use the prefix and end the name with .suffix (i.e. you don't have to include the . in your suffix).\n\nThe function chains keys and values into a string of the form:\n\nkey1=val1_key2=val2_key3=val3\n\nwhile the keys are always sorted alphabetically. If you provide the prefix/suffix the function will do:\n\nprefix_key1=val1_key2=val2_key3=val3.suffix\n\nassuming you chose the default connector, see below. Notice that prefix can be any path, and in addition if it ends with / or \\ then the connector after prefix is ommited (although joinpath should be preferred instead of putting paths in prefix). See default_prefix for more.\n\nsavename can be very conveniently combined with @dict or @ntuple. See also parse_savename.\n\nKeywords\n\nallowedtypes = default_allowed(c) : Only values of type subtyping anything in allowedtypes are used in the name. By default this is (Real, String, Symbol).\naccesses = allaccess(c) : You can also specify which specific keys you want to use with the keyword accesses. By default this is all possible keys c can be accessed with, see allaccess.\ndigits = 3 : Floating point values are rounded to digits. In addition if the following holds:\nround(val; digits = digits) == round(Int, val)\nthen the integer value is used in the name instead.\nscientific = nothing : Number of significant digits used for rounding of floating point values using scientific notation (e.g. 1.65e-7). If nothing, normal rounding is done. \nconnector = \"_\" : string used to connect the various entries.\nexpand::Vector{String} = default_expand(c) : keys that will be expanded to the savename of their contents, to allow for nested containers. By default is empty. Notice that the type of the container must also be allowed in allowedtypes for expand to take effect! Empty containers are always skipped and the savename of the nested arguments is always called with its default arguments (so customization here is possible only by rolling your own container type). If the savename of the nested containers is \"\", it is also skipped.\n\nExamples\n\nd = (a = 0.153456453, b = 5.0, mode = \"double\")\nsavename(d; digits = 4) == \"a=0.1535_b=5_mode=double\"\nsavename(\"n\", d) == \"n_a=0.153_b=5_mode=double\"\nsavename(\"n/\", d) == \"n/a=0.153_b=5_mode=double\"\nsavename(d, \"n\") == \"a=0.153_b=5_mode=double.n\"\nsavename(\"data/n\", d, \"n\") == \"data/n_a=0.153_b=5_mode=double.n\"\nsavename(\"n\", d, \"n\"; connector = \"-\") == \"n-a=0.153-b=5-mode=double.n\"\nsavename(d, allowedtypes = (String,)) == \"mode=double\"\n\nrick = (never = \"gonna\", give = \"you\", up = \"!\");\nsavename(rick) == \"give=you_never=gonna_up=!\" # keys are sorted!\n\n\n\n\n\n","category":"function"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Notice that this naming scheme integrates perfectly with Parameters.jl.","category":"page"},{"location":"name/#Convenience-functions-1","page":"Naming Simulations","title":"Convenience functions","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"Convenience functions are provided to shorten common function calls and easily create named tuples, dictionaries as well as switch between them:","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"@dict\n@savename\n@strdict\n@ntuple\nntuple2dict\ndict2ntuple","category":"page"},{"location":"name/#DrWatson.@dict","page":"Naming Simulations","title":"DrWatson.@dict","text":"@dict vars...\n\nCreate a dictionary out of the given variables that has as keys the variable names and as values their values.\n\nNotice: @dict a b is the correct way to call the macro. @dict a, b is incorrect. If you want to use commas you have to do @dict(a, b).\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = π/3;\n\njulia> @dict ω χ ζ\nDict{Symbol,Any} with 3 entries:\n  :ω => 5\n  :χ => \"test\"\n  :ζ => 1.0472\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@savename","page":"Naming Simulations","title":"DrWatson.@savename","text":"@savename vars...\n\nConvenient combination of chaining a call to @dict on vars and savename.\n\nExamples\n\njulia> a = 0.153456453; b = 5.0; mode = \"double\"\njulia> @savename a b mode\n\"a=0.153_b=5_mode=double\"\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@strdict","page":"Naming Simulations","title":"DrWatson.@strdict","text":"@strdict vars...\n\nSame as @dict but the key type is String.\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.@ntuple","page":"Naming Simulations","title":"DrWatson.@ntuple","text":"@ntuple vars...\n\nCreate a NamedTuple out of the given variables that has as keys the variable names and as values their values.\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = 3.14;\n\njulia> @ntuple ω χ ζ\n(ω = 5, χ = \"test\", ζ = 3.14)\n\n\n\n\n\n","category":"macro"},{"location":"name/#DrWatson.ntuple2dict","page":"Naming Simulations","title":"DrWatson.ntuple2dict","text":"ntuple2dict(nt) -> dict\n\nConvert a NamedTuple to a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.dict2ntuple","page":"Naming Simulations","title":"DrWatson.dict2ntuple","text":"dict2ntuple(dict) -> ntuple\n\nConvert a dictionary (with Symbol or String as key type) to a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"name/#Customizing-savename-1","page":"Naming Simulations","title":"Customizing savename","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"You can customize savename for your own Types. For example you could make it so that it only uses some specific keys instead of all of them, only specific types, or you could make it access data in a different way (maybe even loading files!). You can even make it have a custom prefix!","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"To do that you may extend the following functions:","category":"page"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"DrWatson.allaccess\nDrWatson.access\nDrWatson.default_allowed\nDrWatson.default_prefix\nDrWatson.default_expand","category":"page"},{"location":"name/#DrWatson.allaccess","page":"Naming Simulations","title":"DrWatson.allaccess","text":"allaccess(c)\n\nReturn all the keys c can be accessed using access. For dictionaries/named tuples this is keys(c), for everything else it is fieldnames(typeof(c)).\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.access","page":"Naming Simulations","title":"DrWatson.access","text":"access(c, key)\n\nAccess c with given key. For AbstractDict this is getindex, for anything else it is getproperty.\n\naccess(c, keys...)\n\nWhen given multiple keys, access is called recursively, i.e. access(c, key1, key2) = access(access(c, key1), key2) and so on. For example, if c, c.k1 are NamedTuples then access(c, k1, k2) == c.k1.k2.\n\nnote: Note\nPlease only extend the single key method when customizing access for your own Types.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_allowed","page":"Naming Simulations","title":"DrWatson.default_allowed","text":"default_allowed(c) = (Real, String, Symbol)\n\nReturn the (super-)Types that will be used as allowedtypes in savename or other similar functions.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_prefix","page":"Naming Simulations","title":"DrWatson.default_prefix","text":"default_prefix(c) = \"\"\n\nReturn the prefix that will be used by default in savename or other similar functions.\n\nNotice that if default_prefix is defined for c but a prefix is also given to savename then the two values are merged via joinpath for convenience (if they are not the same of course).\n\nE.g. defining default_prefix(c::MyType) = \"lala\" and calling\n\nsavename(datadir(), mytype)\n\nwill in fact return a string that looks like\n\n\"path/to/data/lala_p1=...\"\n\nThis allows savename to work well with produce_or_load.\n\n\n\n\n\n","category":"function"},{"location":"name/#DrWatson.default_expand","page":"Naming Simulations","title":"DrWatson.default_expand","text":"default_expand(c) = String[]\n\nKeys that should be expanded in their savename within savename. Must be Vector{String} (as all keys are first translated into strings inside savename).\n\n\n\n\n\n","category":"function"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"See Real World Examples for an example of customizing savename. Specifically, have a look at savename and nested containers for a way to","category":"page"},{"location":"name/#Reverse-engineering-savename-1","page":"Naming Simulations","title":"Reverse-engineering savename","text":"","category":"section"},{"location":"name/#","page":"Naming Simulations","title":"Naming Simulations","text":"parse_savename","category":"page"},{"location":"name/#DrWatson.parse_savename","page":"Naming Simulations","title":"DrWatson.parse_savename","text":"parse_savename(filename::AbstractString; kwargs...)\n\nTry to convert a shorthand name produced with savename into a dictionary containing the parameters and their values, a prefix and suffix string. Return prefix, parameters, suffix.\n\nParsing the key-value parts of filename is performed under the assumption that the value is delimited by = and the closest connector. This allows the user to have connector (eg. _) in a key name (variable name) but not in the value part.\n\nKeywords\n\nconnector = \"_\" : string used to connect the various entries.\nparsetypes = (Int, Float64) : tuple used to define the types which should be tried when parsing the values given in filename. Fallback is String.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#Running-and-Listing-Simulations-1","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"","category":"section"},{"location":"run&list/#Preparing-Simulation-Runs-1","page":"Running & Listing Simulations","title":"Preparing Simulation Runs","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"It is very often the case that you want to run \"batch simulations\", i.e. just submit a bunch of different simulations, all using same algorithms and code but just different parameters. This scenario always requires the user to prepare a set of simulation parameter containers which are then passed into some kind of \"main\" function that starts the simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"To make the preparation part simpler we provide the following functionality:","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"dict_list\ndict_list_count","category":"page"},{"location":"run&list/#DrWatson.dict_list","page":"Running & Listing Simulations","title":"DrWatson.dict_list","text":"dict_list(c::Dict)\n\nExpand the dictionary c into a vector of dictionaries. Each entry has a unique combination from the product of the Vector values of the dictionary while the non-Vector values are kept constant for all possibilities. The keys of the entries are the same.\n\nWhether the values of c are iterable or not is of no concern; the function considers as \"iterable\" only subtypes of Vector.\n\nUse the function dict_list_count to get the number of dictionaries that dict_list will produce.\n\nExamples\n\njulia> c = Dict(:a => [1, 2], :b => 4);\n\njulia> dict_list(c)\n3-element Array{Dict{Symbol,Int64},1}:\n Dict(:a=>1,:b=>4)\n Dict(:a=>2,:b=>4)\n\njulia> c[:model] = \"linear\"; c[:run] = [\"bi\", \"tri\"];\n\njulia> dict_list(c)\n4-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:model=>\"linear\")\n\njulia> c[:e] = [[1, 2], [3, 5]];\n\njulia> dict_list(c)\n8-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.dict_list_count","page":"Running & Listing Simulations","title":"DrWatson.dict_list_count","text":"dict_list_count(c) -> N\n\nReturn the number of dictionaries that will be created by calling dict_list(c).\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"Using the above function means that you can write your \"preparation\" step into a single dictionary and then let it automatically expand into many parameter containers. This keeps the code cleaner but also consistent, provided that it follows one simple rule: Anything that is a Vector has many parameters, otherwise it is one parameter. dict_list considers this true irrespectively of what the Vector contains. This allows users to use any iterable custom type as a single \"parameter\" of a simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"See the Preparing & running jobs for a very convenient application!","category":"page"},{"location":"run&list/#Saving-Temporary-Dictionaries-1","page":"Running & Listing Simulations","title":"Saving Temporary Dictionaries","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"The functionality of dict_list is great, but can fall short in cases of submitting jobs to a computer cluster. For serial clusters, each run is submitted to a different Julia process and thus one cannot propagate a Julia in-memory Dict (for parallel clusters using pmap is fine).","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"To balance this, we have here some simple functionality that stores the result of dict_list (or any other dictionary collection, really) to files with temporary names. The names are returned and can then be propagated into a main-like Julia process that can take the temp-name as an input, load the dictionary and then extract the data.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"tmpsave","category":"page"},{"location":"run&list/#DrWatson.tmpsave","page":"Running & Listing Simulations","title":"DrWatson.tmpsave","text":"tmpsave(dicts::Vector{Dict} [, tmp]; kwargs...) -> r\n\nSave each entry in dicts into a unique temporary file in the directory tmp. Then return the list of file names (relative to tmp) that were used for saving each dictionary.\n\ntmp defaults to projectdir(\"_research\", \"tmp\").\n\nSee also dict_list.\n\nKeywords\n\nl = 8 : number of characters in the random string.\nprefix = \"\" : prefix each temporary name will have.\nsuffix = \"bson\" : ending of the temporary names (no need for the dot).\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"An example usage is shown in Using a Serial Cluster.","category":"page"},{"location":"run&list/#Collecting-Results-1","page":"Running & Listing Simulations","title":"Collecting Results","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"note: Requires `DataFrames`\nThe function collect_results! is only available if you do using DataFrames in your Julia session.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"There are cases where you have saved a bunch of simulation results in a bunch of different files in a folder. It is useful to be able to collect all of these results into a single table, in this case a DataFrame. The function collect_results! provides this functionality. Importantly, the function is \"future-proof\" which means that it works nicely even if you add new parameters or remove old parameters from your results as your project progresses!","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"collect_results!\ncollect_results","category":"page"},{"location":"run&list/#DrWatson.collect_results!","page":"Running & Listing Simulations","title":"DrWatson.collect_results!","text":"collect_results!([filename,] folder; kwargs...) -> df\n\nSearch the folder (and possibly all subfolders) for new result-files and add them to df which is a DataFrame containing all the information from each result-file. If a result-file is missing keys that are already columns in df, they will be set as missing. If on the other hand new keys are encountered, a new column will be added and filled with missing for all previous entries.\n\nIf no file exists in filename, then df will be saved there. If however filename exists, the existing df will be first loaded and then reused. The reused df has some results already collected: files already included in df are skipped in subsequent calls to collect_results! while new result-files are simply appended to the dataframe.\n\nfilename defaults to:\n\nfilename = joinpath(dirname(folder), \"results_$(basename(folder)).bson\")\n\nSee also collect_results.\n\nwarning: Warning\ndf contains a column :path which is the path where each result-file is saved to. This is used to not reload and reprocess files already present in df when searching for new ones.If you have an entry :path in your saved result-files this will probably break collect_results (untested).\n\nKeyword Arguments\n\nsubfolders::Bool = false : If true also scan all subfolders of folder for result-files.\nvalid_filetypes = [\".bson\", \".jld\", \".jld2\"]: Only files that have these endings are interpreted as result-files. Other files are skipped.\nverbose = true : Print (using @info) information about the process.\nwhite_list : List of keys to use from result file. By default uses all keys from all loaded result-files.\nblack_list = []: List of keys not to include from result-file.\nspecial_list = []: List of additional (derived) key-value pairs to put in df as explained below.\n\nspecial_list is a Vector{Pair{Symbol, Function}} where each entry is a derived quantity to be included in df. The function entry always takes a single argument, which is the loaded result-file (a dictionary). As an example consider that each result-file contains a field :longvector too large to be included in the df. The quantity of interest is the mean and the variance of said field. To have these values in your results first use black_list = [:longvector] and then define\n\nspecial_list = [ :lv_mean => data -> mean(data[:longvector]),\n                 :lv_lar  => data -> var(data[:longvector]) ]\n\nIn case this operation fails the values will be treated as missing.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.collect_results","page":"Running & Listing Simulations","title":"DrWatson.collect_results","text":"collect_results(folder; kwargs...) -> df\n\nDo exactly the same as collect_results! but don't care to load (or later save) an existing dataframe. Thus all found results files are processed.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"For an example of using this functionality please have a look at the Real World Examples page!","category":"page"},{"location":"save/#Saving-Tools-1","page":"Saving Tools","title":"Saving Tools","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"This page discusses numerous tools that can significantly improve process of saving & loading files, always in a scientific context.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"These tools are also used in the examples demonstrated in the Real World Examples page. After reading the proper documentation here it might be worth it to have a look there as well!","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"info: Saving and loading files\nIn DrWatson we save and load files with the functions wsave(filename, data) and wload(filename). These functions are further used in the tools below, like e.g. tagsave and can be overloaded for your own specific datatype.In addition, wsave ensures that mkpath is always called on the path you are trying to save your file at. We all know how unpleasant it is to run a 2-hour simulation and save no data because FileIO.save complains that the path you are trying to save does not exist...To overload the saving part, add a new method to DrWatson._wsave (notice the _), and to overload the load part add a new method to DrWatson.wload. By overloading these methods you get all the extra functionality of tagsave, safesave, etc., for free for your own types.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"warning: Saving and loading fallback\nBy default we fallback to FileIO.save and FileIO.load for all files and types. This means that you have to install yourself whatever saving backend you want to use. FileIO by itself does not install a package that saves data, it only provides the interface!The suffix of the file name determines which package will be used for actually saving the file. It is your responsibility to know how the saving package works and what input it expects!","category":"page"},{"location":"save/#Safely-saving-data-1","page":"Saving Tools","title":"Safely saving data","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Almost all packages that save data by default overwrite existing files (if given a save name of an existing file). This is the default behavior because often it is desired.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Sometimes it is not though! And the consequences of overwritten data can range from irrelevant to catastrophic. To avoid such an event we provide an alternative way to save data that will never overwrite existing files:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"safesave","category":"page"},{"location":"save/#DrWatson.safesave","page":"Saving Tools","title":"DrWatson.safesave","text":"safesave(filename, data)\n\nSafely save data in filename by ensuring that no existing files are overwritten. Do this by renaming already existing data with a backup-number ending like #1, #2, .... For example if filename = test.bson, the first time you safesave it, the file is saved normally. The second time the existing save is renamed to test_#1.bson and a new file test.bson is then saved.\n\nIf a backup file already exists then its backup-number is incremented (e.g. going from #2 to #3). For example safesaving test.bson a third time will rename the old test_#1.bson to test_#2.bson, rename the old test.bson to test_#1.bson and then save a new test.bson with the latest data.\n\nSee also tagsave.\n\n\n\n\n\n","category":"function"},{"location":"save/#Tagging-a-run-using-Git-1","page":"Saving Tools","title":"Tagging a run using Git","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"For reproducibility reasons (and also to not go insane when asking \"HOW DID I GET THOSE RESUUUULTS\") it is useful to \"tag\" any simulation/result/process using the Git status of the repository.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"To this end we have some functions that can be used to ensure reproducibility:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"tagsave\n@tagsave","category":"page"},{"location":"save/#DrWatson.tagsave","page":"Saving Tools","title":"DrWatson.tagsave","text":"tagsave(file::String, d::Dict; safe = false, gitpath = projectdir(), storepatch = true, force = false)\n\nFirst tag! dictionary d and then save d in file. If safe = true save the file using safesave.\n\n\"Tagging\" means that when saving the dictionary, an extra field :gitcommit is added to establish reproducibility of results using Git. If the Git repository is dirty, one more field :gitpatch is added that stores the difference string.  If a dictionary already contains a key :gitcommit, it is not overwritten, unless, force=true. For more details, see tag!.\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.@tagsave","page":"Saving Tools","title":"DrWatson.@tagsave","text":"@tagsave(file::String, d::Dict; kwargs...)\n\nSame as tagsave but one more field :script is added that records the local path of the script and line number that called @tagsave, see @tag!.\n\n\n\n\n\n","category":"macro"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"The functions also incorporate safesave if need be.","category":"page"},{"location":"save/#Low-level-functions-1","page":"Saving Tools","title":"Low level functions","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"@tagsave internally uses the following low level functions:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"tag!\n@tag!\ngitdescribe\nDrWatson.gitpatch","category":"page"},{"location":"save/#DrWatson.tag!","page":"Saving Tools","title":"DrWatson.tag!","text":"tag!(d::Dict; gitpath = projectdir(), storepatch = true, force = false) -> d\n\nTag d by adding an extra field gitcommit which will have as value the gitdescribe of the repository at gitpath (by default the project's gitpath). Do nothing if a key gitcommit already exists (unless force=true then replace with the new value) or if the Git repository is not found. If the git repository is dirty, i.e. there are un-commited changes, then the output of git diff HEAD is stored in the field gitpatch.  Note that patches for binary files are not stored.\n\nNotice that if String is not a subtype of the value type of d then a new dictionary is created and returned. Otherwise the operation is inplace (and the dictionary is returned again).\n\nTo restore a repository to the state of a particular model-run do:\n\ncheckout the relevant commit with git checkout xyz where xyz is the value stored\napply the patch git apply patch, where the string stored in the gitpatch field needs to be written to the file patch.\n\nExamples\n\njulia> d = Dict(:x => 3, :y => 4)\nDict{Symbol,Int64} with 2 entries:\n  :y => 4\n  :x => 3\n\njulia> tag!(d)\nDict{Symbol,Any} with 3 entries:\n  :y => 4\n  :gitcommit => \"96df587e45b29e7a46348a3d780db1f85f41de04\"\n  :x => 3\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.@tag!","page":"Saving Tools","title":"DrWatson.@tag!","text":"@tag!(d, gitpath = projectdir(), storepatch = true, force = false) -> d\n\nDo the same as tag! but also add another field script that has the path of the script that called @tag!, relative with respect to gitpath. The saved string ends with #line_number, which indicates the line number within the script that @tag! was called at.\n\nExamples\n\njulia> d = Dict(:x => 3)Dict{Symbol,Int64} with 1 entry:\n  :x => 3\n\njulia> @tag!(d) # running from a script or inline evaluation of Juno\nDict{Symbol,Any} with 3 entries:\n  :gitcommit => \"618b72bc0936404ab6a4dd8d15385868b8299d68\"\n  :script => \"test\\stools_tests.jl#10\"\n  :x      => 3\n\n\n\n\n\n","category":"macro"},{"location":"save/#DrWatson.gitdescribe","page":"Saving Tools","title":"DrWatson.gitdescribe","text":"gitdescribe(gitpath = projectdir()) -> gitstr\n\nReturn a string gitstr with the output of git describe if an annotated git tag exists, otherwise the current active commit id of the Git repository present in gitpath, which by default is the currently active project. If the repository is dirty when this function is called the string will end with \"_dirty\".\n\nReturn nothing if gitpath is not a Git repository, i.e. a directory within a git repository.\n\nThe format of the git describe output in general is\n\n`\"TAGNAME-[NUMBER_OF_COMMITS_AHEAD-]gLATEST_COMMIT_HASH[_dirty]\"`\n\nIf the latest tag is v1.2.3 and there are 5 additional commits while the latest commit hash is 334a0f225d9fba86161ab4c8892d4f023688159c, the output will be v1.2.3-5-g334a0f. Notice that git will shorten the hash if there are no ambiguous commits.\n\nMore information about the git describe output can be found on (https://git-scm.com/docs/git-describe)\n\nSee also tag!.\n\nExamples\n\njulia> gitdescribe() # a tag exists\n\"v1.2.3-g7364ab\"\n\njulia> gitdescribe() # a tag doesn't exist\n\"96df587e45b29e7a46348a3d780db1f85f41de04\"\n\njulia> gitdescribe(path_to_a_dirty_repo)\n\"3bf684c6a115e3dce484b7f200b66d3ced8b0832_dirty\"\n\n\n\n\n\n","category":"function"},{"location":"save/#DrWatson.gitpatch","page":"Saving Tools","title":"DrWatson.gitpatch","text":"gitpatch(gitpath = projectdir())\n\nGenerates a patch describing the changes of a dirty repository compared to its last commit; i.e. what git diff HEAD produces. The gitpath needs to point to a directory within a git repository, otherwise nothing is returned.\n\n\n\n\n\n","category":"function"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"Please notice that tag! will operate in place only when possible. If not possible then a new dictionary is returned. Also (importantly) these functions will never error as they are most commonly used when saving simulations and this could risk data not being saved!","category":"page"},{"location":"save/#Produce-or-Load-1","page":"Saving Tools","title":"Produce or Load","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"produce_or_load is a function that very conveniently integrates with savename to either load a file if it exists, or if it doesn't to produce it, save it and then return it!","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"This saves you the effort of checking if a file exists and then loading, or then running some code and saving, or writing a bunch of if clauses in your code. In addition, it attempts to minimize computing energy spent on getting a result.","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"produce_or_load","category":"page"},{"location":"save/#DrWatson.produce_or_load","page":"Saving Tools","title":"DrWatson.produce_or_load","text":"produce_or_load([path=\"\",] c, f; kwargs...) -> file, s\n\nLet s = joinpath(path, savename(prefix, c, suffix)). If a file named s exists then load it and return it, along with the global path that it is saved at (s).\n\nIf the file does not exist then call file = f(c), with f your function that produces your data. Then save file as s and then return file, s. The function f must return a dictionary, the macros @dict and @strdict can help with that.\n\nKeywords\n\ntag = true : Save the file using tagsave.\ngitpath = projectdir() : Path to search for a Git repo.\nsuffix = \"bson\", prefix = default_prefix(c) : Used in savename.\nforce = false : If true then don't check if file s exists and produce it and save it anyway.\nloadfile = true : If false, this function does not actually load the file, but only checks if it exists. The return value in this case is always nothing, s, regardless of whether the file exists or not. If it doesn't exist it is still produced and saved.\nverbose = true : print info about the process, if the file doesn't exist.\nkwargs... : All other keywords are propagated to savename.\n\nSee also savename.\n\n\n\n\n\n","category":"function"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"See Stopping \"Did I run this?\" for an example usage of produce_or_load.","category":"page"},{"location":"save/#Converting-a-struct-to-a-dictionary-1","page":"Saving Tools","title":"Converting a struct to a dictionary","text":"","category":"section"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"savename gives great support for getting a name out of any Julia composite type. To save something though, one needs a dictionary. So the following function can be conveniently used to directly save a struct using any saving function:","category":"page"},{"location":"save/#","page":"Saving Tools","title":"Saving Tools","text":"struct2dict","category":"page"},{"location":"save/#DrWatson.struct2dict","page":"Saving Tools","title":"DrWatson.struct2dict","text":"struct2dict(s) -> d\n\nConvert a Julia composite type s to a dictionary d with key type Symbol that maps each field of s to its value. This can be useful in e.g. saving:\n\ntagsave(savename(s), struct2dict(s))\n\n\n\n\n\n","category":"function"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: DrWatson)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson is a scientific project assistant software. It is a Julia package created to help people \"deal\" with their simulations, simulation parameters, where are files saved, experimental data, scripts, existing simulations, project source code and in general their scientific projects.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"See the Functionality section to get an impression of what you can do with DrWatson. To install, simply type ] add DrWatson in your Julia session.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: JuliaDynamics\nDrWatson is part of JuliaDynamics, check out our website for more cool stuff!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: Poster for DrWatson\nIf you prefer having a concise and visual summary of DrWatson we have prepared a poster for it! Check out the Poster section!","category":"page"},{"location":"#Rationale-1","page":"Introduction","title":"Rationale","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Have you thought things like:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Urgh, I moved my folders and now my load commands don't work anymore!\nHold on, haven't I run this simulation already?\nDo I have to produce a dataframe of my finished simulations AGAIN?!\nWait, are those experiments already processed?\nPFfffff I am tired of typing savename = \"w=$w_f=$f_x=$x.jld2\", can't I do it automatically?\nI wish I could just use Parameters.jl and just translate my simulations into a dataframe.\nYeah you've sent me your project but none of the scripts work...","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson tries to eradicate such bad thoughts and bedtime nightmares.","category":"page"},{"location":"#Functionality-1","page":"Introduction","title":"Functionality","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWarson is a scientific project assistant software. Here is what it can do:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Project Setup : A universal project structure and functions that allow you to consistently and robustly navigate through your project, no matter where it is located on your hard drive.\nNaming Simulations : A robust and deterministic scheme for naming and handling your containers.\nSaving Tools : Tools for safely saving and loading your data, tagging the Git commit ID to your saved files, safety when tagging with dirty repos, and more.\nRunning & Listing Simulations: Tools for producing tables of existing simulations/data, adding new simulation results to the tables, preparing batch parameter containers, and more.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Think of these core aspects of DrWatson as independent islands connected by bridges. If you don't like the approach of one of the islands, you don't have to use it to take advantage of DrWatson!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Applications of DrWatson are demonstrated the Real World Examples page. All of these examples are taken from code of real scientific projects that use DrWatson.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Please note that DrWatson is not a data management system. It is also not a Julia package creator like PkgTemplates.jl nor a package developement tool.","category":"page"},{"location":"#Description-of-DrWatson-1","page":"Introduction","title":"Description of DrWatson","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson follows these simple principles:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Non-Invasive. DrWatson does not require you to follow strict rules or change the way you work and do science in order to use it. In addition DrWatson is function-based: you only have to call a function and everything else just works; you do not have to create additional special struct or other data types. In addition, you also do not have to do anything outside of your code (e.g. command line arguments).\nSimple. The functionality offered is a baseline from where you handle your project as you wish. This makes it more likely to be of general use but also means that you don't have to \"study\" to learn DrWatson: all concepts are simple, everything is easy to understand.\nConsistent. The functionality is identical across all projects and DrWatson offers a universal base project structure.\nAllows increments. You didn't plan your project well enough? Want to add more folders, more files, more variables to your simulations? It's fine.\nReproducibility. DrWatson aims to make your projects fully reproducible using Git, Julia's package manager and consistent naming schemes.\nModular. DrWatson has a flexible modular design (see Functionality) which means you only have to use what fits your project.\nScientific. DrWatson has been beta tested in many real-world scientific projects and has matured based on feedback from scientists.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This is why we believe DrWatson can help you focus on the science and not worry about project code management.","category":"page"},{"location":"#Poster-1","page":"Introduction","title":"Poster","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: poster DrWatson)","category":"page"},{"location":"#Inspirations-1","page":"Introduction","title":"Inspirations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://drivendata.github.io/cookiecutter-data-science/#cookiecutter-data-science","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://discourse.julialang.org/t/computational-experiments-organising-different-algorithms-their-parameters-and-results/10774/7","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"http://neuralensemble.org/sumatra/","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/mohamed82008/ComputExp.jl","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://sacred.readthedocs.io/en/latest/index.html","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://experimentator.readthedocs.io/en/latest/","category":"page"}]
}
