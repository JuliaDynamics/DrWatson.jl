<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Saving Tools · DrWatson</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/logo.ico" rel="icon" type="image/x-icon"/><link href="https://fonts.googleapis.com/css?family=Quicksand|Montserrat|Source+Code+Pro|Lora&amp;display=swap" rel="stylesheet" type="text/css"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DrWatson logo"/></a><div class="docs-package-name"><span class="docs-autofit">DrWatson</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><a class="tocitem" href="../workflow/">DrWatson Workflow Tutorial</a></li><li><a class="tocitem" href="../project/">Project Setup</a></li><li><a class="tocitem" href="../name/">Naming Simulations</a></li><li class="is-active"><a class="tocitem" href>Saving Tools</a><ul class="internal"><li><a class="tocitem" href="#Safely-saving-data-1"><span>Safely saving data</span></a></li><li><a class="tocitem" href="#Tagging-a-run-using-Git-1"><span>Tagging a run using Git</span></a></li><li><a class="tocitem" href="#Produce-or-Load-1"><span>Produce or Load</span></a></li><li><a class="tocitem" href="#Converting-a-struct-to-a-dictionary-1"><span>Converting a struct to a dictionary</span></a></li></ul></li><li><a class="tocitem" href="../run&amp;list/">Running &amp; Listing Simulations</a></li><li><a class="tocitem" href="../real_world/">Real World Examples</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Saving Tools</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Saving Tools</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/master/docs/src/save.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Saving-Tools-1"><a class="docs-heading-anchor" href="#Saving-Tools-1">Saving Tools</a><a class="docs-heading-anchor-permalink" href="#Saving-Tools-1" title="Permalink"></a></h1><p>This page discusses numerous tools that can significantly improve process of saving &amp; loading files, always in a scientific context.</p><p>These tools are also used in the examples demonstrated in the <a href="../real_world/#Real-World-Examples-1">Real World Examples</a> page. After reading the proper documentation here it might be worth it to have a look there as well!</p><p>In DrWatson we save and load files with the functions <code>wsave(filename, data)</code> and <code>wload(filename)</code>. These functions are further used in the tools below, like e.g. <a href="#DrWatson.tagsave"><code>tagsave</code></a> and can be overloaded for your own specific datatype.</p><p>In addition, <code>wsave</code> <strong>ensures</strong> that <code>mkpath</code> is always called on the path you are trying to save your file at. We all know how unpleasant it is to run a 2-hour simulation and save no data because <code>FileIO.save</code> complains that the path you are trying to save at does not exist...</p><p>To overload the saving part, add a new method to <code>DrWatson._wsave(filename, ::YourType)</code> (notice the <code>_</code>). By overloading <code>_wsave</code> you get all the extra functionality of <a href="#DrWatson.tagsave"><code>tagsave</code></a>, <a href="#DrWatson.safesave"><code>safesave</code></a>, etc., for free for your own types (<code>tagsave</code> requires that you save your data as a dictionary).</p><div class="admonition is-warning"><header class="admonition-header">Saving and loading fallback</header><div class="admonition-body"><p>By default we fallback to <code>FileIO.save</code> and <code>FileIO.load</code> for and types. This means that you have to install yourself whatever saving backend you want to use. <code>FileIO</code> by itself does <em>not</em> install a package that saves data, it only provides the interface!</p><p>The <em>suffix</em> of the file name determines which package will be used for actually saving the file. It is <strong>your responsibility</strong> to know how the saving package works and what input it expects!</p></div></div><h2 id="Safely-saving-data-1"><a class="docs-heading-anchor" href="#Safely-saving-data-1">Safely saving data</a><a class="docs-heading-anchor-permalink" href="#Safely-saving-data-1" title="Permalink"></a></h2><p>Almost all packages that save data by default overwrite existing files (if given a save name of an existing file). This is the default behavior because often it is desired.</p><p>Sometimes it is not though! And the consequences of overwritten data can range from irrelevant to catastrophic. To avoid such an event we provide an alternative way to save data that will never overwrite existing files:</p><article class="docstring"><header><a class="docstring-binding" id="DrWatson.safesave" href="#DrWatson.safesave"><code>DrWatson.safesave</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">safesave(filename, data)</code></pre><p>Safely save <code>data</code> in <code>filename</code> by ensuring that no existing files are overwritten. Do this by renaming already existing data with a backup-number ending like <code>#1, #2, ...</code>. For example if <code>filename = test.bson</code>, the first time you <code>safesave</code> it, the file is saved normally. The second time the existing save is renamed to <code>test_#1.bson</code> and a new file <code>test.bson</code> is then saved.</p><p>If a backup file already exists then its backup-number is incremented (e.g. going from <code>#2</code> to <code>#3</code>). For example safesaving <code>test.bson</code> a third time will rename the old <code>test_#1.bson</code> to <code>test_#2.bson</code>, rename the old <code>test.bson</code> to <code>test_#1.bson</code> and then save a new <code>test.bson</code> with the latest <code>data</code>.</p><p>See also <a href="#DrWatson.tagsave"><code>tagsave</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_files.jl#L131-L148">source</a></section></article><h2 id="Tagging-a-run-using-Git-1"><a class="docs-heading-anchor" href="#Tagging-a-run-using-Git-1">Tagging a run using Git</a><a class="docs-heading-anchor-permalink" href="#Tagging-a-run-using-Git-1" title="Permalink"></a></h2><p>For reproducibility reasons (and also to not go insane when asking &quot;HOW DID I GET THOSE RESUUUULTS&quot;) it is useful to &quot;tag&quot; any simulation/result/process using the Git status of the repository.</p><p>To this end we have some functions that can be used to ensure reproducibility:</p><article class="docstring"><header><a class="docstring-binding" id="DrWatson.tagsave" href="#DrWatson.tagsave"><code>DrWatson.tagsave</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tagsave(file::String, d::Dict; safe = false, gitpath = projectdir(), storepatch = true, force = false)</code></pre><p>First <a href="#DrWatson.tag!"><code>tag!</code></a> dictionary <code>d</code> and then save <code>d</code> in <code>file</code>. If <code>safe = true</code> save the file using <a href="#DrWatson.safesave"><code>safesave</code></a>.</p><p>&quot;Tagging&quot; means that when saving the dictionary, an extra field <code>:gitcommit</code> is added to establish reproducibility of results using Git. If the Git repository is dirty, one more field <code>:gitpatch</code> is added that stores the difference string.  If a dictionary already contains a key <code>:gitcommit</code>, it is not overwritten, unless, <code>force=true</code>. For more details, see <a href="#DrWatson.tag!"><code>tag!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_files.jl#L82-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DrWatson.@tagsave" href="#DrWatson.@tagsave"><code>DrWatson.@tagsave</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tagsave(file::String, d::Dict; kwargs...)</code></pre><p>Same as <a href="#DrWatson.tagsave"><code>tagsave</code></a> but one more field <code>:script</code> is added that records the local path of the script and line number that called <code>@tagsave</code>, see <a href="#DrWatson.@tag!"><code>@tag!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_files.jl#L105-L109">source</a></section></article><p>The functions also incorporate <a href="#DrWatson.safesave"><code>safesave</code></a> if need be.</p><h3 id="Low-level-functions-1"><a class="docs-heading-anchor" href="#Low-level-functions-1">Low level functions</a><a class="docs-heading-anchor-permalink" href="#Low-level-functions-1" title="Permalink"></a></h3><p><a href="#DrWatson.@tagsave"><code>@tagsave</code></a> internally uses the following low level functions:</p><article class="docstring"><header><a class="docstring-binding" id="DrWatson.tag!" href="#DrWatson.tag!"><code>DrWatson.tag!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">tag!(d::Dict; gitpath = projectdir(), storepatch = true, force = false) -&gt; d</code></pre><p>Tag <code>d</code> by adding an extra field <code>gitcommit</code> which will have as value the <a href="#DrWatson.gitdescribe"><code>gitdescribe</code></a> of the repository at <code>gitpath</code> (by default the project&#39;s gitpath). Do nothing if a key <code>gitcommit</code> already exists (unless <code>force=true</code> then replace with the new value) or if the Git repository is not found. If the git repository is dirty, i.e. there are un-commited changes, then the output of <code>git diff HEAD</code> is stored in the field <code>gitpatch</code>.  Note that patches for binary files are not stored.</p><p>Notice that the key-type of the dictionary must be <code>String</code> or <code>Symbol</code>. If <code>String</code> is a subtype of the <em>value</em> type of the dictionary, this operation is in-place. Otherwise a new dictionary is created and returned.</p><p>To restore a repository to the state of a particular model-run do:</p><ol><li>checkout the relevant commit with <code>git checkout xyz</code> where xyz is the value stored</li><li>apply the patch <code>git apply patch</code>, where the string stored in the <code>gitpatch</code> field needs to be written to the file <code>patch</code>.</li></ol><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; d = Dict(:x =&gt; 3, :y =&gt; 4)
Dict{Symbol,Int64} with 2 entries:
  :y =&gt; 4
  :x =&gt; 3

julia&gt; tag!(d)
Dict{Symbol,Any} with 3 entries:
  :y =&gt; 4
  :gitcommit =&gt; &quot;96df587e45b29e7a46348a3d780db1f85f41de04&quot;
  :x =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L113-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DrWatson.@tag!" href="#DrWatson.@tag!"><code>DrWatson.@tag!</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia">@tag!(d, gitpath = projectdir(), storepatch = true, force = false) -&gt; d</code></pre><p>Do the same as <a href="#DrWatson.tag!"><code>tag!</code></a> but also add another field <code>script</code> that has the path of the script that called <code>@tag!</code>, relative with respect to <code>gitpath</code>. The saved string ends with <code>#line_number</code>, which indicates the line number within the script that <code>@tag!</code> was called at.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; d = Dict(:x =&gt; 3)Dict{Symbol,Int64} with 1 entry:
  :x =&gt; 3

julia&gt; @tag!(d) # running from a script or inline evaluation of Juno
Dict{Symbol,Any} with 3 entries:
  :gitcommit =&gt; &quot;618b72bc0936404ab6a4dd8d15385868b8299d68&quot;
  :script =&gt; &quot;test\stools_tests.jl#10&quot;
  :x      =&gt; 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L188-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DrWatson.gitdescribe" href="#DrWatson.gitdescribe"><code>DrWatson.gitdescribe</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gitdescribe(gitpath = projectdir()) -&gt; gitstr</code></pre><p>Return a string <code>gitstr</code> with the output of <code>git describe</code> if an annotated git tag exists, otherwise the current active commit id of the Git repository present in <code>gitpath</code>, which by default is the currently active project. If the repository is dirty when this function is called the string will end with <code>&quot;_dirty&quot;</code>.</p><p>Return <code>nothing</code> if <code>gitpath</code> is not a Git repository, i.e. a directory within a git repository.</p><p>The format of the <code>git describe</code> output in general is</p><pre><code class="language-none">`&quot;TAGNAME-[NUMBER_OF_COMMITS_AHEAD-]gLATEST_COMMIT_HASH[_dirty]&quot;`</code></pre><p>If the latest tag is <code>v1.2.3</code> and there are 5 additional commits while the latest commit hash is 334a0f225d9fba86161ab4c8892d4f023688159c, the output will be <code>v1.2.3-5-g334a0f</code>. Notice that git will shorten the hash if there are no ambiguous commits.</p><p>More information about the <code>git describe</code> output can be found on (https://git-scm.com/docs/git-describe)</p><p>See also <a href="#DrWatson.tag!"><code>tag!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; gitdescribe() # a tag exists
&quot;v1.2.3-g7364ab&quot;

julia&gt; gitdescribe() # a tag doesn&#39;t exist
&quot;96df587e45b29e7a46348a3d780db1f85f41de04&quot;

julia&gt; gitdescribe(path_to_a_dirty_repo)
&quot;3bf684c6a115e3dce484b7f200b66d3ced8b0832_dirty&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L4-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DrWatson.gitpatch" href="#DrWatson.gitpatch"><code>DrWatson.gitpatch</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">gitpatch(gitpath = projectdir())</code></pre><p>Generates a patch describing the changes of a dirty repository compared to its last commit; i.e. what <code>git diff HEAD</code> produces. The <code>gitpath</code> needs to point to a directory within a git repository, otherwise <code>nothing</code> is returned.</p><p>Be aware that <code>gitpatch</code> needs a working installation of Git, that  can be found in the current PATH.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L75-L85">source</a></section></article><p>Please notice that <code>tag!</code> will operate in place only when possible. If not possible then a new dictionary is returned. Also (importantly) these functions will <strong>never error</strong> as they are most commonly used when saving simulations and this could risk data not being saved!</p><h2 id="Produce-or-Load-1"><a class="docs-heading-anchor" href="#Produce-or-Load-1">Produce or Load</a><a class="docs-heading-anchor-permalink" href="#Produce-or-Load-1" title="Permalink"></a></h2><p><code>produce_or_load</code> is a function that very conveniently integrates with <a href="../name/#DrWatson.savename"><code>savename</code></a> to either load a file if it exists, or if it doesn&#39;t to produce it, save it and then return it!</p><p>This saves you the effort of checking if a file exists and then loading, or then running some code and saving, or writing a bunch of <code>if</code> clauses in your code. In addition, it attempts to minimize computing energy spent on getting a result.</p><article class="docstring"><header><a class="docstring-binding" id="DrWatson.produce_or_load" href="#DrWatson.produce_or_load"><code>DrWatson.produce_or_load</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">produce_or_load([path=&quot;&quot;,] c, f; kwargs...) -&gt; file, s</code></pre><p>Let <code>s = joinpath(path, savename(prefix, c, suffix))</code>. If a file named <code>s</code> exists then load it and return it, along with the global path that it is saved at (<code>s</code>).</p><p>If the file does not exist then call <code>file = f(c)</code>, with <code>f</code> your function that produces your data. Then save <code>file</code> as <code>s</code> and then return <code>file, s</code>. The function <code>f</code> must return a dictionary, the macros <a href="../name/#DrWatson.@dict"><code>@dict</code></a> and <a href="../name/#DrWatson.@strdict"><code>@strdict</code></a> can help with that.</p><p>You can use <a href="https://docs.julialang.org/en/v1/manual/functions/#Do-Block-Syntax-for-Function-Arguments">do-block</a> instead of defining a function to pass in. For example,</p><pre><code class="language-julia">produce_or_load([path=&quot;&quot;,] c) do c
    # simulation wiht config `c` runs here
end</code></pre><p><strong>Keywords</strong></p><ul><li><code>tag = true</code> : Save the file using <a href="#DrWatson.tagsave"><code>tagsave</code></a>.</li><li><code>gitpath = projectdir()</code> : Path to search for a Git repo.</li><li><code>suffix = &quot;bson&quot;, prefix = default_prefix(c)</code> : Used in <code>savename</code>.</li><li><code>force = false</code> : If <code>true</code> then don&#39;t check if file <code>s</code> exists and produce it and save it anyway.</li><li><code>loadfile = true</code> : If <code>false</code>, this function does not actually load the file, but only checks if it exists. The return value in this case is always <code>nothing, s</code>, regardless of whether the file exists or not. If it doesn&#39;t exist it is still produced and saved.</li><li><code>verbose = true</code> : print info about the process, if the file doesn&#39;t exist.</li><li><code>kwargs...</code> : All other keywords are propagated to <code>savename</code>.</li></ul><p>See also <a href="../name/#DrWatson.savename"><code>savename</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_files.jl#L3-L35">source</a></section></article><p>See <a href="../real_world/#Stopping-&quot;Did-I-run-this?&quot;-1">Stopping &quot;Did I run this?&quot;</a> for an example usage of <code>produce_or_load</code>.</p><h2 id="Converting-a-struct-to-a-dictionary-1"><a class="docs-heading-anchor" href="#Converting-a-struct-to-a-dictionary-1">Converting a struct to a dictionary</a><a class="docs-heading-anchor-permalink" href="#Converting-a-struct-to-a-dictionary-1" title="Permalink"></a></h2><p><a href="../name/#DrWatson.savename"><code>savename</code></a> gives great support for getting a name out of any Julia composite type. To save something though, one needs a dictionary. So the following function can be conveniently used to directly save a struct using any saving function:</p><article class="docstring"><header><a class="docstring-binding" id="DrWatson.struct2dict" href="#DrWatson.struct2dict"><code>DrWatson.struct2dict</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">struct2dict(s) -&gt; d</code></pre><p>Convert a Julia composite type <code>s</code> to a dictionary <code>d</code> with key type <code>Symbol</code> that maps each field of <code>s</code> to its value. This can be useful in e.g. saving:</p><pre><code class="language-none">tagsave(savename(s), struct2dict(s))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L224-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DrWatson.struct2ntuple" href="#DrWatson.struct2ntuple"><code>DrWatson.struct2ntuple</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">struct2ntuple(s) -&gt; n</code></pre><p>Convert a Julia composite type <code>s</code> to a NamedTuple <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/c52918894ed845918178d5fd5cd4da0f32c91e5e/src/saving_tools.jl#L238-L241">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../name/">« Naming Simulations</a><a class="docs-footer-nextpage" href="../run&amp;list/">Running &amp; Listing Simulations »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 February 2021 17:53">Friday 5 February 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
