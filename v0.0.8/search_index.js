var documenterSearchIndex = {"docs":
[{"location":"#","page":"Introduction","title":"Introduction","text":"(Image: DrWatson)","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson is a Julia package created to help people \"deal\" with their simulations, simulation parameters, where are files saved, experimental data, scripts, existing simulations, project source code and in general their scientific projects.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson is currently in alpha and under development!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"info: JuliaDynamics\nDrWatson is part of JuliaDynamics, check out our website for more cool stuff!","category":"page"},{"location":"#Rationale-1","page":"Introduction","title":"Rationale","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Have you thought things like:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Urgh, I moved my folders and now my load commands don't work anymore!\nMaaaan, have I run this simulation already?\nDo I have to produce a dataframe of my finished simulations AGAIN?!\nWait, are those experiments already processed?\nPFfffff I am tired of typing savename = \"w=$w_f=$f_x=$x.jld2, can't I do it automatically?\nI wish I could just use Parameters.jl and just translate my simulations into a dataframe.\nYeah you've sent me your project but none of the scripts work...","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson tries to eradicate such bad thoughts and bedtime nightmares.","category":"page"},{"location":"#Description-of-DrWatson-1","page":"Introduction","title":"Description of DrWatson","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"DrWatson follows these simple principles:","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Minimally Invasive Workflow. DrWatson does not require you to follow strict guidelines or change the way you work and do science.\nBasic. The functionality offered is something simple, a baseline from where you handle your project as you wish.\nConsistent. The functionality is identical across all projects and DrWatson offers a universal base project structure.\nAllows increments. You didn't plan your project well enough? Want to add more folders, more files, more variables to your simulations? It's fine.\nHelpful. DrWatson has been beta tested in real-world scientific projects and has matured based on feedback from scientists.\nReproducible. DrWatson aims to make your projects fully reproducible using Git, Julia's package manager and consistent naming schemes.\nModular. DrWatson has a flexible design (see Functionality) which means you only have to use what fits your project.","category":"page"},{"location":"#Functionality-1","page":"Introduction","title":"Functionality","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"The core aspects of DrWatson are completely independent of each other. If you don't like the approach of one of them you can just not use it!","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Project Setup : A universal project structure and functions that allow you to consistently and robustly navigate through your project, no matter where it is located on your hard drive.\nNaming & Saving Simulations : A robust scheme for saving your data, naming files, tagging the Git commit ID to your saved files, and more.\nRunning & Listing Simulations: Tools for producing tables of existing simulations/data, adding runs to such tables, preparing batch parameter containers, and more.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Applications of DrWatson are demonstrated the Real World Examples page. All of these examples are directly copied from code of real scientific projects that use DrWatson.","category":"page"},{"location":"#Inspirations-1","page":"Introduction","title":"Inspirations","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://drivendata.github.io/cookiecutter-data-science/#cookiecutter-data-science","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://discourse.julialang.org/t/computational-experiments-organising-different-algorithms-their-parameters-and-results/10774/7","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"http://neuralensemble.org/sumatra/","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://github.com/mohamed82008/ComputExp.jl","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://sacred.readthedocs.io/en/latest/index.html","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"https://experimentator.readthedocs.io/en/latest/","category":"page"},{"location":"project/#Project-Setup-1","page":"Project Setup","title":"Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Part of the functionality of DrWatson is creating and navigating through a project setup consistently. This works even if you move your project to a different location/computer and in addition the navigation process is identical across any project that uses DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"For this to work, you only need to follow these rules:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Your science project is also a Julia project defined by a Project.toml file.\nYou first activate this project environment before running any code. See Activating a Project for ways to do this.\nYou use the functions scriptdir, datadir, etc. from DrWatson (see Navigating a Project)","category":"page"},{"location":"project/#Default-Project-Setup-1","page":"Project Setup","title":"Default Project Setup","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Here is the default project setup that DrWatson suggests (and assumes, for the functionality of this page):","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"using DrWatson\nstruct ShowFile\n    file::String\nend\nfunction Base.show(io::IO, ::MIME\"text/plain\", f::ShowFile)\n    write(io, read(f.file))\nend","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"ShowFile(dirname(pathof(DrWatson))*\"/defaults/project_structure.txt\") # hide","category":"page"},{"location":"project/#src-vs-scripts-1","page":"Project Setup","title":"src vs scripts","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Seems like src and scripts folders have pretty similar functionality. However there is a distinction between these two. You can follow these mental rules to know where to put file.jl:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If upon include(\"file.jl\") there is anything being produced, be it data files, plots or even output to the console, then it should be in scripts.\nIf it is functionality used across multiple files or pipelines, it should be in src.\nsrc should only contain files that define functions or types but not output anything. You can also organize src to be a Julia package, or contain multiple Julia packages.","category":"page"},{"location":"project/#Initializing-a-Project-1","page":"Project Setup","title":"Initializing a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To initialize a project as described in the Default Project Setup section, we provide the following function:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"initialize_project","category":"page"},{"location":"project/#DrWatson.initialize_project","page":"Project Setup","title":"DrWatson.initialize_project","text":"initialize_project(path [, name]; kwargs...)\n\nInitialize a scientific project expected by DrWatson inside the given path. If its name is not given, it is assumed to be the folder's name.\n\nThe new project remains activated for you to immidiately add packages.\n\nKeywords\n\nreadme = true : adds a README.md file.\nauthors = nothing : if a string or container of strings, adds the authors in the Project.toml file.\nforce = false : If the path is not empty then throw an error. If however force is true then recursively delete everything in the path and create the project.\ngit = true : Make the project a Git repository.\n\n\n\n\n\n","category":"function"},{"location":"project/#Activating-a-Project-1","page":"Project Setup","title":"Activating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This part of DrWatson's functionality requires you to have your scientific project (and as a consequence, the Julia project) activated. This can be done in multiple ways:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"doing Pkg.activate(\"path/to/project\") programmatically\nusing the startup flag --project path when starting Julia\nby setting the JULIA_PROJECT environment variable\nusing the functions quickactivate and findproject offered by DrWatson.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"We recommend the fourth approach, although it does come with a caveat (see the docstring of quickactivate).","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Here is how it works: the function quickactivate activates a project given some path by recursively searching the path and its parents for a valid Project.toml file. Typically you put this function in your script files like so:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"using DrWatson # DONT USE OTHER PACKAGES HERE!\nquickactivate(@__DIR__, \"Best project in the WOLLRDD\")\n# Now you should start using other packages","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"where the second optional argument can assert if the activated project matches the name you provided. If not the function will throw an error.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"quickactivate\nfindproject","category":"page"},{"location":"project/#DrWatson.quickactivate","page":"Project Setup","title":"DrWatson.quickactivate","text":"quickactivate(path [, name::String])\n\nActivate the project found by findproject of the path, which recursively searches the path and its parents for a valid Julia project file.\n\nOptionally check if name is the same as the activated project's name. If it is not, throw an error.\n\nThis function is first activating the project and then checking if it matches the name.\n\nwarning: Warning\nNote that to access quickactivate you need to be using DrWatson. For this to be possible DrWatson must be already added in the existing global environment. The version of DrWatson loaded therefore will be the one of the global environment, and not of the activated project. To avoid unexpected behavior take care so that these two versions coincide.In addition please be very careful to not write:using DrWatson, Package1, Package2\nquickactivate(@__DIR__)\n# do stuffbut instead load packages after activating the project:using DrWatson\nquickactivate(@__DIR__)\nusing Package1, Package2\n# do stuffThis ensures that the packages you use will all have the versions dictated by your activated project (besides DrWatson, since this is impossible to do using quickactivate).\n\n\n\n\n\n","category":"function"},{"location":"project/#DrWatson.findproject","page":"Project Setup","title":"DrWatson.findproject","text":"findproject(path = pwd()) -> project_path\n\nRecursively search path and its parents for a valid Julia project file (anything in Base.project_names). If it is found return its path, otherwise issue a warning and return nothing.\n\nThe function stops searching if it hits either the home directory or the root directory.\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Notice that to get the current project's name you can use:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectname","category":"page"},{"location":"project/#DrWatson.projectname","page":"Project Setup","title":"DrWatson.projectname","text":"projectname()\n\nReturn the name of the currently active project.\n\n\n\n\n\n","category":"function"},{"location":"project/#Navigating-a-Project-1","page":"Project Setup","title":"Navigating a Project","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"To be able to navigate the project consistently, DrWatson provides the core function","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"projectdir","category":"page"},{"location":"project/#DrWatson.projectdir","page":"Project Setup","title":"DrWatson.projectdir","text":"projectdir()\n\nReturn the directory of the currently active project. Ends with \"/\".\n\nprojectdir(folder::String) = joinpath(projectdir(), folder)*\"/\"\n\nReturn the directory of the folder in the active project.\n\n\n\n\n\n","category":"function"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"Besides the above, the shortcut functions:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"datadir()\nsrcdir()\nplotsdir()\nscriptdir()\npapersdir()","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"immediately return the appropriate subdirectory. These are also defined due to the frequent use of these subdirectories.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"In addition, the return value of all these functions ends with /. This means that you can directly chain them with a file name using just *. E.g. you could do","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"using DrWatson\nfile = makesimulation()\ntagsave(datadir()*\"sims/test.bson\", file)","category":"page"},{"location":"project/#Reproducibility-1","page":"Project Setup","title":"Reproducibility","text":"","category":"section"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"This project setup approach that DrWatson suggests has a very big side-benefit: it is fully reproducible firstly because it uses Julia's suggested project structure, secondly because the navigation only uses local directories and lastly because it is a Git repository.","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"If you send your entire project folder to a colleague, they only need to do:","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"julia> cd(\"path/to/project\")\npkg> activate .\npkg> instantiate","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"All required packages and dependencies will be installed and then any script that was running in your computer will also be running in their computer in the same way!","category":"page"},{"location":"project/#","page":"Project Setup","title":"Project Setup","text":"In addition, with DrWatson you have the possibility of \"tagging\" each simulation created with the commit id, see the discussion around current_commit and tag!.","category":"page"},{"location":"name&save/#Naming-and-Saving-Simulations-1","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"This page discusses numerous tools that make life easier for handling simulations. Most (if not all) of these tools are also used in the examples demonstrated in the Real World Examples page. After reading the proper documentation here it might be worth it to have a look there as well!","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"info: We use `FileIO`\nFor saving and loading files we use FileIO.save and FileIO.load. This means that you have to install yourself whatever saving backend you want to use. FileIO by itself does not install a package that saves data, it only provides the interface!","category":"page"},{"location":"name&save/#Naming-Schemes-1","page":"Naming & Saving Simulations","title":"Naming Schemes","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"A robust naming scheme allows you to create quick names for simulations, create lists of simulations, check existing simulations, etc. More importantly it allows you to easily read and write simulations using a consistent naming scheme.","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"savename\n@dict\n@strdict\n@ntuple","category":"page"},{"location":"name&save/#DrWatson.savename","page":"Naming & Saving Simulations","title":"DrWatson.savename","text":"savename([prefix,], c [, suffix]; kwargs...)\n\nCreate a shorthand name, commonly used for saving a file, based on the parameters in the container c (Dict, NamedTuple or any other Julia composite type, e.g. created with Parameters.jl). If provided use the prefix and end the name with .suffix (i.e. you don't have to include the . in your suffix).\n\nThe function chains keys and values into a string of the form:\n\nkey1=val1_key2=val2_key3=val3\n\nwhile the keys are always sorted alphabetically. If you provide the prefix/suffix the function will do:\n\nprefix_key1=val1_key2=val2_key3=val3.suffix\n\nassuming you chose the default connector, see below. Notice that prefix can be any path and in addition if it ends as a path (/ or \\) then the connector is ommited.\n\nsavename can be very conveniently combined with @dict or @ntuple.\n\nKeywords\n\nallowedtypes = default_allowed(c) : Only values of type subtyping anything in allowedtypes are used in the name. By default this is (Real, String, Symbol).\naccesses = allaccess(c) : You can also specify which specific keys you want to use with the keyword accesses. By default this is all possible keys c can be accessed with, see allaccess.\ndigits = 3 : Floating point values are rounded to digits. In addition if the following holds:\nround(val; digits = digits) == round(Int, val)\nthen the integer value is used in the name instead.\nconnector = \"_\" : string used to connect the various entries.\n\nExamples\n\nd = (a = 0.153456453, b = 5.0, mode = \"double\")\nsavename(d; digits = 4) == \"a=0.1535_b=5_mode=double\"\nsavename(\"n\", d) == \"n_a=0.153_b=5_mode=double\"\nsavename(\"n/\", d) == \"n/a=0.153_b=5_mode=double\"\nsavename(d, \"n\") == \"a=0.153_b=5_mode=double.n\"\nsavename(\"data/n\", d, \"n\") == \"data/n_a=0.153_b=5_mode=double.n\"\nsavename(\"n\", d, \"n\"; connector = \"-\") == \"n-a=0.153-b=5-mode=double.n\"\nsavename(d, allowedtypes = (String,)) == \"mode=double\"\n\nrick = (never = \"gonna\", give = \"you\", up = \"!\");\nsavename(rick) == \"give=you_never=gonna_up=!\" # keys are sorted!\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.@dict","page":"Naming & Saving Simulations","title":"DrWatson.@dict","text":"@dict vars...\n\nCreate a dictionary out of the given variables that has as keys the variable names and as values their values.\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = π/3;\n\njulia> @dict ω χ ζ\nDict{Symbol,Any} with 3 entries:\n  :ω => 5\n  :χ => \"test\"\n  :ζ => 1.0472\n\n\n\n\n\n","category":"macro"},{"location":"name&save/#DrWatson.@strdict","page":"Naming & Saving Simulations","title":"DrWatson.@strdict","text":"@strdict vars...\n\nSame as @dict but the key type is String.\n\n\n\n\n\n","category":"macro"},{"location":"name&save/#DrWatson.@ntuple","page":"Naming & Saving Simulations","title":"DrWatson.@ntuple","text":"@ntuple vars...\n\nCreate a NamedTuple out of the given variables that has as keys the variable names and as values their values.\n\nExamples\n\njulia> ω = 5; χ = \"test\"; ζ = 3.14;\n\njulia> @ntuple ω χ ζ\n(ω = 5, χ = \"test\", ζ = 3.14)\n\n\n\n\n\n","category":"macro"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"Notice that this naming scheme integrates perfectly with Parameters.jl.","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"Two convenience functions are also provided to easily switch between named tuples and dictionaries:","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"ntuple2dict\ndict2ntuple","category":"page"},{"location":"name&save/#DrWatson.ntuple2dict","page":"Naming & Saving Simulations","title":"DrWatson.ntuple2dict","text":"ntuple2dict(nt) -> dict\n\nConvert a NamedTuple to a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.dict2ntuple","page":"Naming & Saving Simulations","title":"DrWatson.dict2ntuple","text":"dict2ntuple(dict) -> ntuple\n\nConvert a dictionary (with Symbol or String as key type) to a NamedTuple.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#Customizing-savename-1","page":"Naming & Saving Simulations","title":"Customizing savename","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"You can customize savename for your own Types. For example you could make it so that it only uses some specific keys instead of all of them, only specific types, or you could make it access data in a different way (maybe even loading files!). You can even make it have a custom prefix!","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"To do that you may extend the following functions:","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"DrWatson.allaccess\nDrWatson.access\nDrWatson.default_allowed\nDrWatson.default_prefix","category":"page"},{"location":"name&save/#DrWatson.allaccess","page":"Naming & Saving Simulations","title":"DrWatson.allaccess","text":"allaccess(c)\n\nReturn all the keys c can be accessed using access. For dictionaries/named tuples this is keys(c), for everything else it is fieldnames(typeof(c)).\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.access","page":"Naming & Saving Simulations","title":"DrWatson.access","text":"access(c, key)\n\nAccess c with given key. For AbstractDict this is getindex, for anything else it is getproperty.\n\naccess(c, keys...)\n\nWhen given multiple keys, access is called recursively, i.e. access(c, key1, key2) = access(access(c, key1), key2) and so on. For example, if c, c.k1 are NamedTuples then access(c, k1, k2) == c.k1.k2.\n\nnote: Note\nPlease only extend the single key method when customizing access for your own Types.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.default_allowed","page":"Naming & Saving Simulations","title":"DrWatson.default_allowed","text":"default_allowed(c) = (Real, String, Symbol)\n\nReturn the (super-)Types that will be used as allowedtypes in savename or other similar functions.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.default_prefix","page":"Naming & Saving Simulations","title":"DrWatson.default_prefix","text":"default_prefix(c) = \"\"\n\nReturn the prefix that will be used by default in savename or other similar functions.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"See Real World Examples for an example of customizing savename.","category":"page"},{"location":"name&save/#Safely-saving-data-1","page":"Naming & Saving Simulations","title":"Safely saving data","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"Almost all packages that save data by default overwrite existing files (if given a save name of an existing file). This is the default behavior because often it is desired.","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"Sometimes it is not though! And the consequences of overwritten data can be from irrelevant to catastrophic. To avoid such an event we provide an alternative way to save data that will never overwrite existing files:","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"safesave","category":"page"},{"location":"name&save/#DrWatson.safesave","page":"Naming & Saving Simulations","title":"DrWatson.safesave","text":"safesave(filename, data)\n\nSafely save data in filename by ensuring that no existing files are overwritten. Do this by renaming already existing data with a backup-number ending like #1, #2, .... For example if filename = test.bson, the first time you safesave it, the file is saved normally. The second time the existing save is renamed to test_#1.bson and a new file test.bson is then saved.\n\nIf a backup file already exists then its backup-number is incremented (e.g. going from #2 to #3). For example safesaving test.bson a third time will rename the old test_#1.bson to test_#2.bson, rename the old test.bson to test_#1.bson and then save a new test.bson with the latest data.\n\nSee also tagsave.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#Tagging-a-run-using-Git-1","page":"Naming & Saving Simulations","title":"Tagging a run using Git","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"For reproducibility reasons (and also to not go insane when asking \"HOW DID I GET THOSE RESUUUULTS\") it is useful to \"tag\" any simulation/result/process with the Git commit of the repository.","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"To this end there are two functions that can be used to ensure reproducibility:","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"current_commit\ntag!","category":"page"},{"location":"name&save/#DrWatson.current_commit","page":"Naming & Saving Simulations","title":"DrWatson.current_commit","text":"current_commit(path = projectdir()) -> commit\n\nReturn the current active commit id of the Git repository present in path, which by default is the project path. If the repository is dirty when this function is called the string will end with \"_dirty\".\n\nReturn nothing if path is not a Git repository.\n\nSee also tag!.\n\nExamples\n\njulia> current_commit()\n\"96df587e45b29e7a46348a3d780db1f85f41de04\"\n\njulia> current_commit(path_to_dirty_repo)\n\"3bf684c6a115e3dce484b7f200b66d3ced8b0832_dirty\"\n\n\n\n\n\n","category":"function"},{"location":"name&save/#DrWatson.tag!","page":"Naming & Saving Simulations","title":"DrWatson.tag!","text":"tag!(d::Dict, path = projectdir()) -> d\n\nTag d by adding an extra field commit which will have as value the current_commit of the repository at path (by default the project's path). Do nothing if a key commit already exists or if the Git repository is not found.\n\nNotice that if String is not a subtype of the value type of d then a new dictionary is created and returned. Otherwise the operation is inplace (and the dictionary is returned again).\n\nExamples\n\njulia> d = Dict(:x => 3, :y => 4)\nDict{Symbol,Int64} with 2 entries:\n  :y => 4\n  :x => 3\n\njulia> tag!(d)\nDict{Symbol,Any} with 3 entries:\n  :y      => 4\n  :commit => \"96df587e45b29e7a46348a3d780db1f85f41de04\"\n  :x      => 3\n\n\n\n\n\n","category":"function"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"Please notice that tag! will operate in place only when possible. If not possible then a new dictionary is returned. Also (importantly) these functions will never error as they are most commonly used when saving simulations and this could risk data not being saved!","category":"page"},{"location":"name&save/#Automatic-Tagging-during-Saving-1","page":"Naming & Saving Simulations","title":"Automatic Tagging during Saving","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"If you don't want to always call tag! before saving a file, you can just use the function tagsave, which can also nicely incorporate safesave if need be!","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"tagsave","category":"page"},{"location":"name&save/#DrWatson.tagsave","page":"Naming & Saving Simulations","title":"DrWatson.tagsave","text":"tagsave(file::String, d::Dict; projectpath, safe)\n\nFirst tag! dictionary d and then save d in file.\n\nKeywords\n\nprojectpath = projectdir() : Path of the Git repository.\nsafe = false : Save the file using safesave.\n\n\n\n\n\n","category":"function"},{"location":"name&save/#Produce-or-Load-1","page":"Naming & Saving Simulations","title":"Produce or Load","text":"","category":"section"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"produce_or_load is a function that very conveniently integrates with savename to either load a file if it exists, or if it doesn't to produce it, save it and then return it!","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"This saves you the effort of checking if a file exists and then loading, or then running some code and saving, or writing a bunch of if clauses in your code! produce_or_load really shines when used in interactive sessions where some results require a couple of minutes to complete.","category":"page"},{"location":"name&save/#","page":"Naming & Saving Simulations","title":"Naming & Saving Simulations","text":"produce_or_load","category":"page"},{"location":"name&save/#DrWatson.produce_or_load","page":"Naming & Saving Simulations","title":"DrWatson.produce_or_load","text":"produce_or_load([prefix=\"\",] c, f; kwargs...) -> file\n\nLet s = savename(prefix, c, suffix). If a file named s exists then load it and return it.\n\nIf the file does not exist then call file = f(c), save file as s and then return the file. The function f must return a dictionary. The macros @dict and strdict can help with that.\n\nKeywords\n\ntag = true : Add the Git commit of the project in the saved file.\nprojectpath = projectdir() : Path to search for a Git repo.\nsuffix = \"bson\" : Used in savename.\nforce = false : If true then don't check if file s exists and produce it and save it anyway.\nkwargs... : All other keywords are propagated to savename.\n\nSee also savename and tag!.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#Running-and-Listing-Simulations-1","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"","category":"section"},{"location":"run&list/#Preparing-Simulation-Runs-1","page":"Running & Listing Simulations","title":"Preparing Simulation Runs","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"It is very often the case that you want to run \"batch simulations\", i.e. just submit a bunch of different simulations, all using same algorithms and code but just different parameters. This scenario always requires the user to prepare a set of simulation parameter containers which are then passed into some kind of \"main\" function that starts the simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"To make the preparation part simpler we provide the following functionality:","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"dict_list\ndict_list_count","category":"page"},{"location":"run&list/#DrWatson.dict_list","page":"Running & Listing Simulations","title":"DrWatson.dict_list","text":"dict_list(c)\n\nExpand the dictionary c into a vector of dictionaries. Each entry has a unique combination from the product of the Vector values of the dictionary while the non-Vector values are kept constant for all possibilities. The keys of the entries are the same.\n\nWhether the values of c are iterable or not is of no concern; the function considers as \"iterable\" only subtypes of Vector.\n\nUse the function dict_list_count to get the number of dictionaries that dict_list will produce.\n\nExamples\n\njulia> c = Dict(:a => [1, 2], :b => 4);\n\njulia> dict_list(c)\n3-element Array{Dict{Symbol,Int64},1}:\n Dict(:a=>1,:b=>4)\n Dict(:a=>2,:b=>4)\n\njulia> c[:model] = \"linear\"; c[:run] = [\"bi\", \"tri\"];\n\njulia> dict_list(c)\n4-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:model=>\"linear\")\n\njulia> c[:e] = [[1, 2], [3, 5]];\n\njulia> dict_list(c)\n8-element Array{Dict{Symbol,Any},1}:\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[1, 2],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"bi\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>1,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n Dict(:a=>2,:b=>4,:run=>\"tri\",:e=>[3, 5],:model=>\"linear\")\n\n\n\n\n\n","category":"function"},{"location":"run&list/#DrWatson.dict_list_count","page":"Running & Listing Simulations","title":"DrWatson.dict_list_count","text":"dict_list_count(c) -> N\n\nReturn the number of dictionaries that will be created by calling dict_list(c).\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"Using the above function means that you can write your \"preparation\" step into a single dictionary and then let it automatically expand into many parameter containers. This keeps the code cleaner but also consistent, provided that it follows one rule: Anything that is a Vector has many parameters, otherwise it is one parameter. dict_list considers this true irrespectively of what the Vector contains. This allows users to use any iterable custom type as a single \"parameter\" of a simulation.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"See the Real World Examples for a very convenient application!","category":"page"},{"location":"run&list/#Collecting-Results-1","page":"Running & Listing Simulations","title":"Collecting Results","text":"","category":"section"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"note: Requires `DataFrames`\nThe function collect_results is only available if you do using DataFrames in your Julia session.","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"There are cases where you have saved a bunch of simulation results in a bunch of different files in a folder. It is useful to be able to collect all of these results into a single table, in this case a DataFrame. The function collect_results provides this functionality. Importantly, the function is \"future-proof\" which means that it works nicely even if you add new parameters or remove old parameters from your results as your project progresses!","category":"page"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"collect_results","category":"page"},{"location":"run&list/#DrWatson.collect_results","page":"Running & Listing Simulations","title":"DrWatson.collect_results","text":"collect_results(folder; kwargs...) -> df\n\nSearch the folder (and possibly all subfolders) for new result-files and add them to df which is a DataFrame containing all the information from each result-file. BSON is used for both loading and saving, until FileIO interface includes BSON.\n\nIf a result-file is missing keys that are already columns in df, they will be set as missing. If on the other hand new keys are encountered, a new column will be added and filled with missing for all previous entries.\n\nYou can re-use an existing df that has some results already collected. Files already included in df are skipped in subsequent calls to collect_results (see keywords).\n\nwarning: Warning\ndf contains a column :path which is the path where each result-file is saved to. This is used to not re-load and re-process files already present in df when searching for new ones.If you have an entry :path in your saved result-files this will probably break collect_results (untested).\n\nKeyword Arguments\n\nsubfolders::Bool = false : If true also scan all subfolders of folder for result-files.\nfilename = joinpath(dirname(folder), \"results_$(basename(folder)).bson\": Path to load df from and to save it to. If given the empty string \"\" then df is not loaded/saved (it is always returned).\nvalid_filetypes = [\".bson\", \".jld\", \".jld2\"]: Only files that have these endings are interpreted as result-files. Other files are skipped.\nverbose = true : Print (using @info) information about the process.\nwhite_list : List of keys to use from result file. By default uses all keys from all loaded result-files.\nblack_list = []: List of keys not to include from result-file.\nspecial_list = []: List of additional (derived) key-value pairs to put in df as explained below.\n\nspecial_list is a Vector{Pair{Symbol, Function}} where each entry is a derived quantity to be included in df. The function entry always takes a single argument, which is the loaded result-file (a dictionary). As an example consider that each result-file contains a field :longvector too large to be included in the df. The quantity of interest is the mean and the variance of said field. To have these values in your results first use black_list = [:longvector] and then define\n\nspecial_list = [ :lv_mean => data -> mean(data[:longvector]),\n                 :lv_lar  => data -> var(data[:longvector]) ]\n\nIn case this operation fails the values will be treated as missing.\n\n\n\n\n\n","category":"function"},{"location":"run&list/#","page":"Running & Listing Simulations","title":"Running & Listing Simulations","text":"For an example of using this functionality please have a look at the Real World Examples page!","category":"page"},{"location":"real_world/#Real-World-Examples-1","page":"Real World Examples","title":"Real World Examples","text":"","category":"section"},{"location":"real_world/#Easy-local-directories-1","page":"Real World Examples","title":"Easy local directories","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"I setup all my science projects using DrWatson's suggested setup, using initialize_project. Then, every file in every project has a start that looks like this:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"MagneticBilliardsLyapunovs\")\nusing DynamicalBilliards, PyPlot, LinearAlgebra\n\ninclude(srcdir()*\"plot_perturbationgrowth.jl\")\ninclude(srcdir()*\"unitcells.jl\")","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"In all projects I save data using datadir():","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using BSON\n\nbson(datadir()*\"mushrooms/Λ_N=$N.bson\", (@dict Λ Λσ ws hs description))","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The advantage of this approach is that it will always work regardless of if I move the specific file to a different subfolder (which is very often necessary) or whether I move the entire project folder somewhere else!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example from another project. You will notice that another advantage is that I can use identical syntax to access the data or source folders even though I have different projects!","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"EmbeddingResearch\")\nusing FileIO, Parameters\nusing TimeseriesPrediction, LinearAlgebra, Statistics\n\ninclude(srcdir()*\"systems/barkley.jl\")\ninclude(srcdir()*\"nrmse.jl\")","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"that ends with","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"FileIO.save(\n    savename(datadir()*\"sim/bk\", simulation, \"jld2\"),\n    @strdict U V simulation\n)","category":"page"},{"location":"real_world/#savename-and-tagging-1","page":"Real World Examples","title":"savename and tagging","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The combination of using savename and tagsave makes it easy and fast to save output in a way that is consistent, robust and reproducible. Here is an example from a project:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\nquickactivate(@__DIR__, \"EmbeddingResearch\")\nusing TimeseriesPrediction, LinearAlgebra, Statistics\ninclude(srcdir()*\"systems/barkley.jl\")\n\nΔTs = [1.0, 0.5, 0.1] # resolution of the saved data\nNs = [50, 150] # spatial extent\nfor N ∈ Ns, ΔT ∈ ΔTs\n    T = 10050 # we can offset up to 1000 units\n    every = round(Int, ΔT/barkley_Δt)\n    seed = 1111\n\n    simulation = @ntuple T N ΔT seed\n    U, V = barkley(T, N, every; seed = seed)\n\n    tagsave(\n        savename(datadir()*\"sim/bk\", simulation, \"bson\"),\n        @dict U V simulation\n    )\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This saves files that look like:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"path/to/project/data/sim/bk_N=50_T=10050_seed=1111_ΔT=1.bson","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"and each file is a dictionary with four fields: :U, :V, :simulation, :commit. When I read this file I know exactly what was the source code that produced it (provided that I am not sloppy and commit code changes regularly :P).","category":"page"},{"location":"real_world/#Customizing-savename-1","page":"Real World Examples","title":"Customizing savename","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a simple (but not from a real project) example for customizing savename. We are using a common struct Experiment across different experiments with cats and mice. In this example we are also using Parameters for a convenient default constructor.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We first define the relevant types.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson, Parameters, Dates\n\n# Define a type hierarchy we use at experiments\nabstract type Species end\nstruct Mouse <: Species end\nstruct Cat <: Species end\n\n@with_kw struct Experiment{S<:Species}\n    n::Int = 50\n    c::Float64 = 10.0\n    x::Float64 = 0.2\n    date::Date = Date(Dates.now())\n    species::S = Mouse()\n    scientist::String = \"George\"\nend\n\ne1 = Experiment()\ne2 = Experiment(species = Cat())","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"For analyzing our experiments we need information about the species used, and to use multiple dispatch latter on we decide to make this information associated with a Type.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now, we want to customize savename. We start by extending DrWatson.default_prefix:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_prefix(e::Experiment) = \"Experiment_\"*string(e.date)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"However this is not good enough for us, as the information about the species is not contained in savename. We have to extend DrWatson.default_allowed like so:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.default_allowed(::Experiment) = (Real, String, Species)\n\nsavename(e1)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"To make printing better we can extend Base.string, which is what DrWatson uses internally in savename to display values.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Base.string(::Mouse) = \"mouse\"\nBase.string(::Cat) = \"cat\"\nnothing # hide","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Lastly, let's say that the information of which scientist performed the experiment is not really relevant for savename. We can extend the last method, DrWatson.allaccess:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"DrWatson.allaccess(::Experiment) = (:n, :c, :x, :species)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"so that only those four fields will be used (notice that the date field is anyway used in default_prefix). We finally have:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"println( savename(e1) )\nprintln( savename(e2) )","category":"page"},{"location":"real_world/#Stopping-\"Did-I-run-this?\"-1","page":"Real World Examples","title":"Stopping \"Did I run this?\"","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It can become very tedious to have a piece of code that you may or may not have run and may or may not have saved the produced data. You then constantly ask yourself \"Did I run this?\". Typically one uses isfile and an if clause to either load a file or run some code. Especially in the cases where the code takes only a couple of minutes to finish you are left in a dilemma \"Is it even worth it to save?\".","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"This is the dilemma that produce_or_load resolves. You can wrap your code in a function and then produce_or_load will take care of the rest for you! I found it especially useful in scripts that generate figures for a publication.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is an example; originally I had this piece of code:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"WTEST = HTEST = 0.1:0.1:2.0\nHS = WS = [0.5, 1.0, 1.5]\nN = 10000; T = 10000.0\n\ntoypar_w = [[] for l in HS]\nfor (z, h) in enumerate(HS)\n    println(\"h = $h\")\n    for (i, w) in enumerate(WTEST)\n        toyp = toyparameters(h, w, N, T)\n        push!(toypar_w[z], toyp)\n    end\nend\ntoypar_h = [[] for l in HS]\nfor (wi, w) in enumerate(WS)\n    println(\"w = $w\")\n    for h in HTEST\n        toyp = toyparameters(h, w, N, T)\n        push!(toypar_h[wi], toyp)\n    end\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"that was taking some minutes to run. To use the function produce_or_load I first have to wrap this code in a high level function like so:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"WTEST = HTEST = 0.1:0.1:2.0\nHS = WS = [0.5, 1.0, 1.5]\n\nfunction g(d)\n    @unpack N, T = d\n\n    toypar_w = [[] for l in HS]\n    for (z, h) in enumerate(HS)\n        println(\"h = $h\")\n        for (i, w) in enumerate(WTEST)\n            toyp = toyparameters(h, w, N, T)\n            push!(toypar_w[z], toyp)\n        end\n    end\n    toypar_h = [[] for l in HS]\n    for (wi, w) in enumerate(WS)\n        println(\"w = $w\")\n        for h in HTEST\n            toyp = toyparameters(h, w, N, T)\n            push!(toypar_h[wi], toyp)\n        end\n    end\n\n    return @dict toypar_w toypar_h\nend\n\nN = 2000; T = 2000.0\nfile = produce_or_load(\n    datadir()*\"mushrooms/toy\", # prefix\n    @dict(N, T), # container\n    g # function\n)\n@unpack toypar_w, toypar_h = file","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now every time I run this code block the function tests automatically whether the file exists and only if it does not the code is run.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"The extra step is that I have to extract the useful data I need from the container file. Thankfully the @unpack macro from Parameters.jl makes this super easy.","category":"page"},{"location":"real_world/#Preparing-runs-1","page":"Real World Examples","title":"Preparing runs","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Here is a shortened script from a project that uses dict_list:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DrWatson\n\ngeneral_args = Dict(\n    \"model\" => [\"barkley\", \"kuramoto\"],\n    \"noise\" => 0.075,\n    \"noisy_training\" => [true, false],\n    \"N\" => [50, 100],\n    \"embedding\" => [ #(γ, τ, r, c)\n    (4, 5, 1, 0.34), (4, 6, 1, 0.28), (8, 3, 1, 0.2)]\n)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nprintln(\"Total dictionaries made: \", length(dicts))\ndicts[1]","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Now how you use these dictionaries is up to you. Here we will use map (identical process for using pmap) but in other scenarios you might want to submit many individual jobs to a computer cluster.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Let's say I have written a function that takes in one of these dictionaries and saves the file somewhere locally:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using BSON\nmkpath(datadir()*\"results\")\n\nfunction cross_estimation(data)\n    γ, τ, r, c = data[\"embedding\"]\n    N = data[\"N\"]\n    # add fake results:\n    data[\"x\"] = rand()\n    data[\"error\"] = rand(10)\n    # Save data:\n    prefix = datadir()*\"results/$(data[\"model\"])\"\n    data[\"noisy_training\"] && (prefix *= \"noisy\")\n    BSON.bson(\n        savename(\n            prefix,\n            (@dict γ τ r c N),\n            \"bson\"\n            ),\n        data\n    )\n    return true\nend","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"To run all my simulations I just do:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"dicts = dict_list(general_args)\nmap(cross_estimation, dicts)\n\n# load one of the files to be sure everything is ok:\nfilename = readdir(datadir()*\"results\")[1]\nfile = BSON.load(datadir()*\"results/\"*filename)","category":"page"},{"location":"real_world/#Listing-completed-runs-1","page":"Real World Examples","title":"Listing completed runs","text":"","category":"section"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"Continuing from the above example, we now want to collect the results of all these simulations into a single DataFrame. We will do that with the function collect_results.","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"It is quite simple actually! But because we don't want to include the error, we have to black-list it:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"using DataFrames # this is necessary to access collect_results!\nblack_list = [\"error\"]\nres = collect_results(datadir()*\"results\"; black_list = black_list)","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We can take also advantage of the basic processing functionality of collect_results to use the excluded \"error\" column, replacing it with its average value:","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"rm(datadir()*\"results_results.bson\") # delete existing dataframe\n\nusing Statistics: mean\nspecial_list = [:avrg_error => data -> mean(data[\"error\"])]\nres = collect_results(\n      datadir()*\"results\",\n      black_list = black_list,\n      special_list = special_list\n)\n\ndelete!(res, :path) # don't show path this time","category":"page"},{"location":"real_world/#","page":"Real World Examples","title":"Real World Examples","text":"We had to do rm(\"results_results.bson\") because the files that have already been processed (in our case all of them) would not have been processed a second time.","category":"page"}]
}
