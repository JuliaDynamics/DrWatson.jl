<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Handling Simulations · DrWatson</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>DrWatson</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../project/">Project Setup</a></li><li class="current"><a class="toctext" href>Handling Simulations</a><ul class="internal"><li><a class="toctext" href="#Naming-Schemes-1">Naming Schemes</a></li><li><a class="toctext" href="#Tagging-a-run-using-Git-1">Tagging a run using Git</a></li><li><a class="toctext" href="#Preparing-Simulation-Runs-1">Preparing Simulation Runs</a></li><li><a class="toctext" href="#Simulation-Tables-1">Simulation Tables</a></li><li><a class="toctext" href="#Produce-or-Load-1">Produce or Load</a></li></ul></li><li><a class="toctext" href="../real_world/">Real World Examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Handling Simulations</a></li></ul><a class="edit-page" href="https://github.com/JuliaDynamics/DrWatson.jl/blob/master/docs/src/savenames.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Handling Simulations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Handling-Simulations-1" href="#Handling-Simulations-1">Handling Simulations</a></h1><p>This page discusses numerous tools that make life easier for handling simulations. Most (if not all) of these tools are also used in the examples demonstrated in the <a href="@ref"><code>Real World Examples</code></a> page. After reading the proper documentation here it might be worth it to have a look there as well!</p><h2><a class="nav-anchor" id="Naming-Schemes-1" href="#Naming-Schemes-1">Naming Schemes</a></h2><p>A robust naming scheme allows you to create quick names for simulations, create lists of simulations, check existing simulations, etc. More importantly it allows you to easily read and write simulations using a consistent naming scheme.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.savename" href="#DrWatson.savename"><code>DrWatson.savename</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">savename([prefix,], c [, suffix]; kwargs...)</code></pre><p>Create a shorthand name, commonly used for saving a file, based on the parameters in the container <code>c</code> (<code>Dict</code>, <code>NamedTuple</code> or any other Julia composite type, e.g. created with Parameters.jl). If provided use the <code>prefix</code> and end the name with <code>.suffix</code> (i.e. you don&#39;t have to include the <code>.</code> in your <code>suffix</code>).</p><p>The function chains keys and values into a string of the form:</p><pre><code class="language-julia">key1=val1_key2=val2_key3=val3</code></pre><p>while the keys are <strong>always sorted alphabetically.</strong> If you provide the prefix/suffix the function will do:</p><pre><code class="language-julia">prefix_key1=val1_key2=val2_key3=val3.suffix</code></pre><p>assuming you chose the default <code>connector</code>, see below. Notice that if <code>prefix</code> can be any path and in addition if it ends as a path (<code>/</code> or <code>\</code>) then the <code>connector</code> is ommited.</p><p><code>savename</code> can be very conveniently combined with <a href="#DrWatson.@dict"><code>@dict</code></a> or <a href="#DrWatson.@ntuple"><code>@ntuple</code></a>.</p><p><strong>Keywords</strong></p><ul><li><code>allowedtypes = (Real, String, Symbol)</code> : Only values of type subtyping anything in <code>allowedtypes</code> are used in the name.</li><li><code>accesses = allaccess(c)</code> : You can also specify which specific keys you want to use with the keyword <code>accesses</code>. By default this is all possible keys <code>c</code> can be accessed with, see <a href="#DrWatson.allaccess"><code>allaccess</code></a>.</li><li><code>digits = 3</code> : Floating point values are rounded to <code>digits</code>. In addition if the following holds:<pre><code class="language-julia">round(val; digits = digits) == round(Int, val)</code></pre>then the integer value is used in the name instead.</li><li><code>connector = &quot;_&quot;</code> : string used to connect the various entries.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia">d = (a = 0.153456453, b = 5.0, mode = &quot;double&quot;)
savename(d; digits = 4) == &quot;a=0.1535_b=5_mode=double&quot;
savename(&quot;n&quot;, d) == &quot;n_a=0.153_b=5_mode=double&quot;
savename(&quot;n/&quot;, d) == &quot;n/a=0.153_b=5_mode=double&quot;
savename(d, &quot;n&quot;) == &quot;a=0.153_b=5_mode=double.n&quot;
savename(&quot;data/n&quot;, d, &quot;n&quot;) == &quot;data/n_a=0.153_b=5_mode=double.n&quot;
savename(&quot;n&quot;, d, &quot;n&quot;; connector = &quot;-&quot;) == &quot;n-a=0.153-b=5-mode=double.n&quot;
savename(d, allowedtypes = (String,)) == &quot;mode=double&quot;

rick = (never = &quot;gonna&quot;, give = &quot;you&quot;, up = &quot;!&quot;);
savename(rick) == &quot;give=you_never=gonna_up=!&quot; # keys are sorted!</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.@dict" href="#DrWatson.@dict"><code>DrWatson.@dict</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@dict vars...</code></pre><p>Create a dictionary out of the given variables that has as keys the variable names and as values their values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ω = 5; χ = &quot;test&quot;; ζ = π/3;

julia&gt; @dict ω χ ζ
Dict{Symbol,Any} with 3 entries:
  :ω =&gt; 5
  :χ =&gt; &quot;test&quot;
  :ζ =&gt; 1.0472</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.@strdict" href="#DrWatson.@strdict"><code>DrWatson.@strdict</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@strdict vars...</code></pre><p>Same as <a href="#DrWatson.@dict"><code>@dict</code></a> but the key type is <code>String</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.@ntuple" href="#DrWatson.@ntuple"><code>DrWatson.@ntuple</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@ntuple vars...</code></pre><p>Create a <code>NamedTuple</code> out of the given variables that has as keys the variable names and as values their values.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ω = 5; χ = &quot;test&quot;; ζ = 3.14;

julia&gt; @ntuple ω χ ζ
(ω = 5, χ = &quot;test&quot;, ζ = 3.14)</code></pre></div></div></section><p>Notice that this naming scheme integrates perfectly with Parameters.jl.</p><p>Two convenience functions are also provided to easily switch between named tuples and dictionaries:</p><pre><code class="language-none">ntupled2dict
dict2ntuple</code></pre><h3><a class="nav-anchor" id="Customizing-savename-1" href="#Customizing-savename-1">Customizing <code>savename</code></a></h3><p>You can customize <a href="#DrWatson.savename"><code>savename</code></a> for your own Types. For example you could make it so that it only uses some specific keys instead of all of them, or you could make it access data in a different way (maybe even loading files!).</p><p>To do that you need to extend the following two functions:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.allaccess" href="#DrWatson.allaccess"><code>DrWatson.allaccess</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">allaccess(c)</code></pre><p>Return all the keys <code>c</code> can be accessed using <a href="#DrWatson.access"><code>access</code></a>. For dictionaries/named tuples this is <code>keys(c)</code>, for everything else it is <code>fieldnames(typeof(c))</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.access" href="#DrWatson.access"><code>DrWatson.access</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">access(c, key)</code></pre><p>Access <code>c</code> with given key. For <code>AbstractDict</code> this is <code>getindex</code>, for anything else it is <code>getproperty</code>.</p></div></div></section><h2><a class="nav-anchor" id="Tagging-a-run-using-Git-1" href="#Tagging-a-run-using-Git-1">Tagging a run using Git</a></h2><p>For reproducibility reasons (and also to not go insane when asking &quot;HOW DID I GET THOSE RESUUUULTS&quot;) it is useful to &quot;tag!&quot; any simulation/result/process with the Git commit of the repository.</p><p>To this end there are two functions that can be used to ensure reproducibility:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.current_commit" href="#DrWatson.current_commit"><code>DrWatson.current_commit</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">current_commit(path = projectdir()) -&gt; commit</code></pre><p>Return the current active commit id of the Git repository present in <code>path</code>, which by default is the project path. If the repository is dirty when this function is called the string will end with <code>&quot;_dirty&quot;</code>.</p><p>See also <a href="#DrWatson.tag!"><code>tag!</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; current_commit()
&quot;96df587e45b29e7a46348a3d780db1f85f41de04&quot;

julia&gt; current_commit(path_to_dirty_repo)
&quot;3bf684c6a115e3dce484b7f200b66d3ced8b0832_dirty&quot;</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.tag!" href="#DrWatson.tag!"><code>DrWatson.tag!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tag!(d::Dict, path = projectdir()) -&gt; d</code></pre><p>Tag <code>d</code> by adding an extra field <code>commit</code> which will have as value the <a href="#DrWatson.current_commit"><code>current_commit</code></a> of the repository at <code>path</code> (by default the project&#39;s path). Does not operate if a key <code>commit</code> already exists.</p><p>Notice that if <code>String</code> is not a subtype of the value type of <code>d</code> then a new dictionary is created and returned. Otherwise the operation is inplace (and the dictionary is returned again).</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; d = Dict(:x =&gt; 3, :y =&gt; 4)
Dict{Symbol,Int64} with 2 entries:
  :y =&gt; 4
  :x =&gt; 3

julia&gt; tag!(d)
Dict{Symbol,Any} with 3 entries:
  :y      =&gt; 4
  :commit =&gt; &quot;96df587e45b29e7a46348a3d780db1f85f41de04&quot;
  :x      =&gt; 3</code></pre></div></div></section><p>Please notice that <code>tag!</code> will operate in place only when possible. If not possible then a new dictionary is returned. Also (importantly) these functions will <strong>never error</strong> as they are most commonly used when saving simulations and this could risk data not being saved.</p><h3><a class="nav-anchor" id="Automatic-Tagging-during-Saving-1" href="#Automatic-Tagging-during-Saving-1">Automatic Tagging during Saving</a></h3><p>WIP. (adding the <code>tag!</code> functionality automatically with a <code>save</code> call)</p><h2><a class="nav-anchor" id="Preparing-Simulation-Runs-1" href="#Preparing-Simulation-Runs-1">Preparing Simulation Runs</a></h2><p>It is very often the case that you want to run &quot;batch simulations&quot;, i.e. just submit a bunch of different simulations, all using same algorithms and code but just different parameters. This scenario always requires the user to prepare a set of simulation parameter containers which are then passed into some kind of &quot;main&quot; function that starts the simulation.</p><p>To make the preparation part simpler we provide the following functionality:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.dict_list" href="#DrWatson.dict_list"><code>DrWatson.dict_list</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dict_list(c)</code></pre><p>Expand the dictionary <code>c</code> into a vector of dictionaries. Each entry has a unique combination from the product of the <code>Vector</code> values of the dictionary while the non-<code>Vector</code> values are kept constant for all possibilities. The keys of the entries are the same.</p><p>Whether the values of <code>c</code> are iterable or not is of no concern; the function considers as &quot;iterable&quot; only subtypes of <code>Vector</code>.</p><p>Use the function <a href="#DrWatson.dict_list_count"><code>dict_list_count</code></a> to get an estimate of how many dictionaries will <code>dict_list</code> produce.</p><p><strong>Examples</strong></p><pre><code class="language-julia">julia&gt; c = Dict(:a =&gt; [1, 2], :b =&gt; 4);

julia&gt; dict_list(c)
3-element Array{Dict{Symbol,Int64},1}:
 Dict(:a=&gt;1,:b=&gt;4)
 Dict(:a=&gt;2,:b=&gt;4)

julia&gt; c[:model] = &quot;linear&quot;; c[:mode] = [&quot;bi&quot;, &quot;tri&quot;];

julia&gt; dict_list(c)
4-element Array{Dict{Symbol,Any},1}:
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:model=&gt;&quot;linear&quot;)

julia&gt; c[:e] = [[1, 2], [3, 5]];

julia&gt; dict_list(c)
8-element Array{Dict{Symbol,Any},1}:
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:e=&gt;[1, 2],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:e=&gt;[1, 2],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:e=&gt;[1, 2],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:e=&gt;[1, 2],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:e=&gt;[3, 5],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;bi&quot;,:e=&gt;[3, 5],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;1,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:e=&gt;[3, 5],:model=&gt;&quot;linear&quot;)
 Dict(:a=&gt;2,:b=&gt;4,:mode=&gt;&quot;tri&quot;,:e=&gt;[3, 5],:model=&gt;&quot;linear&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DrWatson.dict_list_count" href="#DrWatson.dict_list_count"><code>DrWatson.dict_list_count</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">dict_list_count(c) -&gt; N</code></pre><p>Return the number of dictionaries that will be created by calling <code>dict_list(c)</code>.</p></div></div></section><p>Using the above function means that you can write your &quot;preparation&quot; step into a single dictionary and then let it automatically expand into many parameter containers. This keeps the code cleaner but also consistent, provided that it follows one rule: <strong>Anything that is a <code>Vector</code> has many parameters, otherwise it is one parameter</strong>. <a href="#DrWatson.dict_list"><code>dict_list</code></a> considers this true irrespectively of what the <code>Vector</code> contains. This allows users to use any iterable custom type as a single &quot;parameter&quot; of a simulation.</p><p>See the <a href="@ref"><code>Real World Examples</code></a> for a very convenient application!</p><h2><a class="nav-anchor" id="Simulation-Tables-1" href="#Simulation-Tables-1">Simulation Tables</a></h2><p>WIP. (Adding simulation runs to a table/csv/dataframe)</p><h2><a class="nav-anchor" id="Produce-or-Load-1" href="#Produce-or-Load-1">Produce or Load</a></h2><p>WIP. (loading a simulation or producing it if it doesn&#39;t exist)</p><footer><hr/><a class="previous" href="../project/"><span class="direction">Previous</span><span class="title">Project Setup</span></a><a class="next" href="../real_world/"><span class="direction">Next</span><span class="title">Real World Examples</span></a></footer></article></body></html>
